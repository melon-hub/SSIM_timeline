<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WFP Schedule Planner</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Primary Colors */
            --navy-primary: rgb(3, 6, 69);
            --orange-accent: rgb(254, 88, 0);
            
            /* Supporting Colors */
            --navy-light: rgba(3, 6, 69, 0.1);
            --navy-hover: rgba(3, 6, 69, 0.05);
            --orange-light: rgba(254, 88, 0, 0.1);
            
            /* Text Colors */
            --text-primary: rgb(3, 6, 69);
            --text-secondary: rgb(75, 85, 99);
            --text-light: rgb(107, 114, 128);
            --navy-light-lighter: rgba(3, 6, 69, 0.05); /* For even lighter borders */
            
            /* Background */
            --bg-gradient: linear-gradient(135deg, 
                rgba(3, 6, 69, 0.02) 0%, 
                rgba(254, 88, 0, 0.02) 100%);
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-gradient);
            color: var(--text-primary);
            min-height: 100vh;
        }
        .page-section-constrained {
            max-width: 80rem;
            margin: 2rem auto;
            padding: 0 1.5rem;
        }

        /* Typography System */
        .section-title {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--navy-primary);
            border-bottom: 2px solid var(--orange-accent);
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }

        .element-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--navy-primary);
            margin-bottom: 0.75rem;
        }

        .description {
            font-size: 0.875rem;
            color: var(--text-secondary);
            line-height: 1.5;
        }
        .table-responsive { 
            overflow-x: auto; 
            width: 100%; 
        }
        .table-responsive::-webkit-scrollbar { height: 8px; width: 8px; }
        .table-responsive::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .table-responsive::-webkit-scrollbar-thumb { background: #a0aec0; border-radius: 10px; }
        .table-responsive::-webkit-scrollbar-thumb:hover { background: #718096; }
        
        button, input[type="text"], input[type="date"], input[type="number"], textarea, select {
            padding: 0.75rem 1rem;
            margin-bottom: 0.75rem;
            border-radius: 0.5rem;
            border: 1px solid var(--navy-light);
            background-color: white;
            color: var(--text-primary);
            transition: all 0.2s ease;
        }

        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: var(--navy-primary);
            box-shadow: 0 0 0 3px var(--navy-light);
        }

        button { 
            font-weight: 500;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: var(--navy-primary);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
        }

        .btn-primary:hover {
            background: var(--orange-accent);
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: white;
            color: var(--navy-primary);
            border: 1px solid var(--navy-light);
            padding: 0.75rem 1.5rem;
        }

        .btn-secondary:hover {
            background: var(--navy-hover);
        }

        #toast-message {
            position: fixed;
            bottom: 20px; /* Changed back to bottom */
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem 1.5rem;
            background-color: var(--navy-primary);
            color: white;
            border-radius: 0.75rem;
            z-index: 1070; /* Keeping increased z-index */
            opacity: 0;
            transition: all 0.3s ease;
            box-shadow: 0 10px 15px -3px rgba(3, 6, 69, 0.1);
            font-weight: 500;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #toast-message.show { opacity: 1; transform: translateX(-50%) translateY(0); }
        #toast-message.hide { transform: translateX(-50%) translateY(60px); } /* Slide down to hide */

        /* --- CSS Grid Calendar Styles --- */
        .calendar-grid-container-wrapper { 
            overflow-x: auto;
            width: 100%;
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(3, 6, 69, 0.1);
            margin: 1.5rem 0;
        }
        .calendar-grid-container {
            display: grid;
            grid-template-columns: minmax(4.5rem, max-content) repeat(31, minmax(50px, 1fr)); 
            border: 1px solid var(--navy-light);
            border-radius: 0.75rem;
            overflow: hidden;
        }
       
        .calendar-grid-header { 
            text-align: center;
            font-size: 0.75rem; 
            font-weight: 600; 
            padding: 0.75rem 0.5rem;
            background-color: var(--navy-primary); 
            color: white;
            border-bottom: 1px solid var(--navy-light);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .calendar-grid-header:last-child { border-right: none; }

        .calendar-month-header-placeholder { 
            position: sticky; 
            left: 0;
            z-index: 11; 
        }
        .calendar-grid-month-name { 
            padding: 0.75rem 0.25rem; 
            position: sticky;
            left: 0;
            background-color: var(--navy-light); 
            z-index: 10; 
            border-right: 1px solid var(--navy-light); 
            border-bottom: 1px solid var(--navy-light);
            display: flex;
            align-items: center; 
            justify-content: center;
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--navy-primary);
            /* text-transform: uppercase; */ /* Removed to make text narrower */
            letter-spacing: normal;
        }
        .calendar-grid-container > .calendar-grid-month-name:nth-last-child(-n+32) { 
            border-bottom: none;
        }


        .calendar-grid-day-cell {
    min-height: 75px; 
    height: auto; 
    border-right: 1px solid var(--navy-light);
    border-bottom: 1px solid var(--navy-light);
    padding: 0.25rem 0.25rem; /* Reduced top/bottom and left/right padding */
    vertical-align: top;
    text-align: left; 
            font-size: 0.75rem;
            background: white;
            transition: all 0.2s ease;
            transition: background-color 0.15s ease-in-out; 
        }
        .calendar-grid-day-cell:last-child { 
             border-right: none;
        }
         .calendar-grid-container > .calendar-grid-day-cell:nth-last-child(-n+31) {
            border-bottom: none;
        }


        .calendar-grid-day-cell:not(.empty-day):hover { 
            background-color: var(--navy-hover);
            transform: scale(1.02);
            box-shadow: 0 2px 4px rgba(3, 6, 69, 0.05);
            z-index: 1;
        }
        .day-number-wrapper {
            font-size: 0.875rem; 
            font-weight: 600; 
            color: var(--navy-primary); 
            text-align: center; 
            margin-bottom: 0.125rem; /* Further reduced margin */
            display: block;
            padding: 0.25rem; /* Default padding for non-current day numbers */
            border-radius: 0.25rem;
            width: -moz-max-content; /* Fit content width */
            width: max-content;      /* Fit content width */
            margin-left: auto;       /* Center the block */
            margin-right: auto;      /* Center the block */
        }
        /* Professional weekend styling with pill effect */
        .calendar-grid-container .calendar-grid-day-cell.weekend {
            position: relative;
            background-color: rgba(3, 6, 69, 0.02);
            border: 1px solid rgba(3, 6, 69, 0.1);
        }
        
        /* Weekend styling for day numbers: Individual pill effect */
        .weekend .day-number-wrapper {
            background-color: rgba(3, 6, 69, 0.4); /* More prominent navy pill */
            color: white; /* White text for good contrast */
            padding: 0.2rem 0.4rem; /* Adjust padding for pill size */
            border-radius: 0.375rem; /* Rounded corners for the pill */
            font-weight: 600; /* Correctly placed */
        }
        .events-wrapper {
            display: flex; flex-direction: column; gap: 1px; align-items: center;
        }
        .event-text-in-cell {
            font-size: 0.75rem; 
            color: #1f2937; 
            line-height: 1.2; 
            padding: 2px 1px;
            text-align: center; 
            width: 100%; 
            white-space: nowrap; 
            overflow: hidden;    
            text-overflow: ellipsis; 
            display: block; 
        }
        .event-month-abbr {
            white-space: nowrap;
            display: inline-block; 
        }

        /* Zoom Level Specific Styles */
        .calendar-zoom-0 .event-text-in-cell { 
            font-size: 0.7rem; 
            white-space: normal; 
            overflow: visible;    
            text-overflow: clip;
            overflow-wrap: break-word; 
            line-height: 1.15; 
            padding: 3px 2px; 
        } 
        .calendar-zoom-1 .event-text-in-cell { 
            font-size: 0.7rem; 
            line-height: 1.15; 
            padding: 1px;    
        }
        /* Removed .calendar-zoom-2 and .calendar-zoom-3 styles */

        /* Event type styling - clean and professional */
        .calendar-grid-day-cell.publish { background-color: #fef9c3; } 
        .calendar-grid-day-cell.planning { background-color: #e0f2fe; }
        .calendar-grid-day-cell.publicHoliday { background-color: #f3f4f6; }
        .calendar-grid-day-cell.empty-day { background-color: #f9fafb; } 

        /* Styles for past and current dates */
        .past-date:not(.publish):not(.planning):not(.publicHoliday):not(.empty-day) { 
            background-color: #f3f4f6; /* Light gray for past, non-event days */
        }
        /* .past-date { opacity: 0.7; } /* Old opacity rule, now handled by specific background or left as is for event days */
        
        .past-date.empty-day { 
            background-color: #f8f9fa; /* Ensure empty past days are consistent if they were already gray */
        }
        
        /* Past event specific styling */
        .past-event {
            position: relative;
            border-left: 2px dotted rgba(107, 114, 128, 0.4); /* Subtle dotted border */
        }

        .current-date { 
            /* border: 2px solid var(--orange-accent) !important; /* Removed border */
            box-sizing: border-box; 
            position: relative; 
            z-index: 2; 
        }
        .current-date .day-number-wrapper { 
            background-color: var(--navy-primary);
            color: white !important;
            font-weight: 700 !important;
            border-radius: 0.375rem; /* Corresponds to Tailwind's rounded-md */
            padding: 0.2rem 0.4rem; /* Specific padding for the pill */
            /* display: block; /* Inherited */
            /* width: -moz-max-content; /* Inherited */
            /* width: max-content; /* Inherited */
            line-height: 1.2; /* Adjust for vertical centering of text in pill */
            /* margin-left: auto; /* Inherited */
            /* margin-right: auto; /* Inherited */
        }
        /* End of styles for past and current dates */

        /* Today's date highlight with enhanced pill styling */
        .calendar-grid-day-cell.today {
            box-shadow: 0 0 0 2px var(--navy-primary);
            border-radius: 0.5rem;
            z-index: 5; /* Higher z-index to ensure today appears above weekend pills */
            position: relative;
        }
        .today .day-number-wrapper {
            background-color: var(--navy-primary);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
        }
        /* Ensures weekend pill doesn't break today's highlight */
        .calendar-grid-day-cell.today.weekend {
            border-radius: 0.5rem !important;
            /* Overrides to ensure today styling takes precedence */
            border-left: 2px solid var(--navy-primary) !important;
            border-right: 2px solid var(--navy-primary) !important;
            border-top: 2px solid var(--navy-primary) !important;
            border-bottom: 2px solid var(--navy-primary) !important;
            box-shadow: none;
            /* Special background for weekend+today */
            background-color: rgba(3, 6, 69, 0.05); /* --navy-light-lighter or --navy-hover */
        }

        .legend-item { display: inline-flex; align-items: center; font-size: 0.75rem; margin-right: 1rem; margin-bottom: 0.25rem; }
        .legend-color { 
            width: 14px; 
            height: 14px; 
            margin-right: 0.5rem; 
            border: 1px solid #a0aec0; 
            flex-shrink: 0; 
            display: inline-block; 
        }
        .legend-color.publish { 
            background-color: #fef9c3; 
            border-color: #e6c300; 
        } 
        .legend-color.planning { 
            background-color: #e0f2fe; 
            border-color: #a0c8e0; 
        } 
        .legend-color.publicHoliday { 
            background-color: #f3f4f6; 
            border-color: #d1d5db; 
        }
        .legend-color.weekend-text-indicator {
            color: #f87171; 
            font-weight: 600;
            background-color: transparent; 
            border: none !important; /* Ensure no border from general .legend-color */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0 1px; 
            line-height: 1; 
            box-sizing: border-box; 
        }


        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(3, 6, 69, 0.75);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1060; 
            opacity: 0;
            display: none; 
            transition: opacity 0.3s ease; 
        }
        .modal-overlay.active {
            opacity: 1;
            display: flex !important; 
        }
        .modal-content {
            background: white;
            padding: 1.5rem; 
            border-radius: 1rem;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 25px -5px rgba(3, 6, 69, 0.2);
            border: 1px solid var(--navy-light);
        }
        .modal-content label { display: block; margin-bottom: 0.25rem; font-weight: 500; font-size: 0.875rem; }
        .modal-content input[type="date"], .modal-content input[type="number"], .modal-content select {
            width: 100%; margin-bottom: 0.75rem; 
        }
        .info-icon {
            cursor: help;
            margin-left: 0.25rem; /* Tailwind ml-1 */
            padding: 0.1rem 0.2rem; /* Small padding to increase hover area */
            color: #60a5fa; /* Tailwind blue-500 */
            font-weight: bold;
            display: inline-block;
            position: relative;
            user-select: none;
        }

        /* Modified Date Indicator - shows when dates have been manually adjusted */
        .date-modified {
            position: relative;
        }
        .date-modified::before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 3px;
            height: 70%;
            background-color: var(--orange-accent);
            border-radius: 2px;
        }
        .date-modified-indicator {
            display: inline-block;
            width: 6px;
            height: 6px;
            background-color: var(--orange-accent);
            border-radius: 50%;
            margin-left: 6px;
            vertical-align: middle;
            animation: pulse-subtle 2s ease-in-out infinite;
        }
        @keyframes pulse-subtle {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(0.9); }
        }
        .modified-row {
            background: linear-gradient(90deg, rgba(254, 88, 0, 0.08) 0%, transparent 15%) !important;
        }
        .modified-row td:first-child {
            position: relative;
        }
        .modified-row td:first-child::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background-color: var(--orange-accent);
        }

        /* Approval Status Toggle Buttons */
        .status-btn-pending {
            background-color: #fef9c3;
            border-color: #eab308 !important;
            color: #a16207;
        }
        .status-btn-pending.inactive {
            background-color: #f9fafb;
            border-color: #d1d5db !important;
            color: #9ca3af;
        }
        .status-btn-approved {
            background-color: #dcfce7;
            border-color: #22c55e !important;
            color: #15803d;
        }
        .status-btn-approved.inactive {
            background-color: #f9fafb;
            border-color: #d1d5db !important;
            color: #9ca3af;
        }

        /* Tab System */
        .tabs-container {
            border: 1px solid var(--navy-light);
            border-radius: 0.75rem;
            background: white;
            box-shadow: 0 2px 4px rgba(3, 6, 69, 0.05);
            margin-bottom: 2rem;
        }

        .tabs-header {
            display: flex;
            border-bottom: 1px solid var(--navy-light);
            background: var(--navy-light);
            border-top-left-radius: 0.75rem;
            border-top-right-radius: 0.75rem;
            padding: 0.5rem;
            gap: 0.5rem;
        }

        .tab-button {
            padding: 0.75rem 1.5rem;
            font-weight: 500;
            color: var(--navy-primary);
            background: white;
            border: 1px solid var(--navy-light);
            border-radius: 0.5rem;
            margin: 0 0.25rem;
        }

        .tab-button:hover {
            background: var(--navy-hover);
        }

        .tab-button.active {
            background: var(--navy-primary);
            color: white;
            border-color: var(--navy-primary);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-content {
            display: none;
            padding: 1.5rem;
            max-width: 32rem;
            margin-left: auto;
            margin-right: auto;
        }

        .tab-content.active {
            display: block;
        }

        /* Container Width */
        .container-narrow {
            max-width: 32rem;
            margin-left: auto;
            margin-right: auto;
        }

        /* Settings Sections */
        .settings-section { 
            margin-bottom: 2rem; 
        }
        .settings-section:last-child { 
            margin-bottom: 0;
        }
        .settings-section-title {
            color: var(--navy-primary);
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        .settings-parameter-group {
            border: 1px solid var(--navy-light); 
            border-radius: 0.75rem; 
            padding: 1.5rem; 
            margin-bottom: 1.5rem;
            background-color: white; 
            box-shadow: 0 2px 4px rgba(3, 6, 69, 0.05);
        }

        /* Color Presets */
        .color-preset-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .color-preset {
            padding: 1.5rem;
            border-radius: 0.5rem;
            border: 2px solid transparent;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .color-preset:hover {
            transform: scale(1.05);
        }

        .color-preset.selected {
            border-color: var(--navy-primary);
        }
        .settings-grid-item {
            display: grid;
            grid-template-columns: repeat(2, 1fr); 
            gap: 1rem; 
            align-items: center; 
            margin-bottom: 0.75rem; 
        }
        @media (max-width: 768px) { 
            .settings-grid-item {
                grid-template-columns: 1fr; 
            }
        }
        .settings-grid-item label {
            font-weight: 500;
            color: #4b5563; 
        }
        .settings-grid-item .description {
            font-size: 0.8rem;
            color: #6b7280;
            padding-left: 0.5rem;
        }

        /* Collapsible Table Styles */
        .collapsible-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none; 
        }
        .collapsible-arrow {
            transition: transform 0.3s ease;
            font-size: 1.25rem; 
        }
        .collapsible-header.collapsed .collapsible-arrow {
            transform: rotate(-90deg);
        }
        .table-content-collapsed {
            display: none;
        }

        /* Event Filter Dropdown Styles */
        #eventFilterDropdown label {
            display: flex;
            align-items: center;
            font-size: 0.875rem;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            transition: background-color 0.2s;
        }
        #eventFilterDropdown label:hover {
            background-color: var(--navy-hover);
        }
        #eventFilterDropdown input[type="checkbox"] {
            margin-right: 0.5rem;
            margin-bottom: 0; /* Override general input margin */
            padding: 0; /* Override general input padding */
            height: 1rem;
            width: 1rem;
            accent-color: var(--navy-primary);
        }

    </style>
</head>
<body class="p-4 md:p-8">

    <div id="settingsPage" style="display: none;" class="max-w-4xl mx-auto">
        <div class="bg-white p-6 md:p-8 rounded-xl shadow-xl">
            <div class="mb-6 pb-2 border-b-2 border-[var(--orange-accent)]"> 
                <div class="flex items-center"> 
                    <button onclick="showPage('mainPage')" title="Back to Calculator" class="p-2 text-2xl text-gray-600 hover:text-blue-600 mr-2">
                        &larr;
                    </button>
                    <h2 class="section-title !mb-0 !border-b-0 !pb-0 flex-grow text-center">Settings</h2>
                </div>
            </div>
            
            <div class="tabs-container">
                <div class="tabs-header">
                    <button class="tab-button active" onclick="switchTab('calculationParams')">Calculation Parameters</button>
                    <button class="tab-button" onclick="switchTab('publicHolidays')">Public Holidays</button>
                    <button class="tab-button" onclick="switchTab('calendar')">Calendar</button>
                    <button class="tab-button" onclick="switchTab('rosterDefinitions')">Roster Definitions</button>
                    <button class="tab-button" onclick="switchTab('addBidPeriodTab')">Add Bid Period</button>
                </div>

                <div id="calculationParams" class="tab-content active">
                    <div class="settings-section">
                        <h3 class="element-title">SP Cutoff Rule</h3>
                        <div class="settings-parameter-group">
                            <div class="settings-grid-item">
                                <label for="settingSpCutoffDay">Day of Month:</label>
                                <input type="number" id="settingSpCutoffDay" min="1" max="31" class="w-full">
                            </div>
                            <div class="settings-grid-item">
                                <label for="settingSpCutoffMonthsPrior">Months Prior to Roster Start:</label>
                                <input type="number" id="settingSpCutoffMonthsPrior" min="0" class="w-full">
                            </div>
                            <div class="settings-grid-item">
                                <label for="settingSpCutoffWeekendAdjust">Weekend Adjustment:</label>
                                <select id="settingSpCutoffWeekendAdjust" class="w-full">
                                    <option value="nextWorkingDay">Move to Next Working Day</option>
                                    <option value="previousWorkingDay">Move to Previous Working Day</option>
                                    <option value="none">None (Allow Weekend)</option>
                                </select>
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h3 class="element-title">Date Offsets</h3>
                        <div class="settings-parameter-group">
                            <div class="settings-grid-item">
                                <label for="settingSpFeedbackOffset">SP Feedback (working days):</label>
                                <input type="number" id="settingSpFeedbackOffset" min="0" class="w-full">
                            </div>
                            <div class="settings-grid-item">
                                <label for="settingTradeOffOffset">Trade Off (working days):</label>
                                <input type="number" id="settingTradeOffOffset" min="0" class="w-full">
                            </div>
                            <div class="settings-grid-item">
                                <label for="settingSsimHandoverOffset">SSIM Handover (working days):</label>
                                <input type="number" id="settingSsimHandoverOffset" min="0" class="w-full">
                            </div>
                            <div class="mt-2">
                                <input type="checkbox" id="settingSsimFridayRule" class="mr-2">
                                <label for="settingSsimFridayRule">If SSIM Handover is Friday, move to preceding Thursday</label>
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h3 class="element-title">Publish Date Offsets</h3>
                        <div class="settings-parameter-group">
                            <div class="settings-grid-item">
                                <label for="settingTechCrewPublishOffset">Tech Crew Publish (calendar days before):</label>
                                <input type="number" id="settingTechCrewPublishOffset" class="w-full">
                            </div>
                            <div class="settings-grid-item">
                                <label for="settingCabinCrewPublishOffset">Cabin Crew Publish (calendar days before):</label>
                                <input type="number" id="settingCabinCrewPublishOffset" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h3 class="element-title">New Event Offsets</h3>
                        <div class="settings-parameter-group">
                            <div class="settings-grid-item">
                                <label for="settingTrainingHandoverOffset">Training Handover (days after SSIM Handover):</label>
                                <input type="number" id="settingTrainingHandoverOffset" class="w-full">
                            </div>
                            <div class="settings-grid-item">
                                <label for="settingCbPairingPublishTechOffset">CB Pairing Publish Tech (work days before Bid Close Tech):</label>
                                <input type="number" id="settingCbPairingPublishTechOffset" class="w-full">
                            </div>
                            <div class="settings-grid-item">
                                <label for="settingBiddingClosureTechOffset">Bidding Closure Tech (days before Roster Build Tech):</label>
                                <input type="number" id="settingBiddingClosureTechOffset" class="w-full">
                            </div>
                            <div class="settings-grid-item">
                                <label for="settingRosterBuildCommenceTechOffset">Roster Build Tech (days before Tech Publish):</label>
                                <input type="number" id="settingRosterBuildCommenceTechOffset" class="w-full">
                            </div>
                            <div class="settings-grid-item">
                                <label for="settingRosterBuildCommenceCabinOffset">Roster Build Cabin (days before Cabin Publish):</label>
                                <input type="number" id="settingRosterBuildCommenceCabinOffset" class="w-full">
                            </div>
                        </div>
                    </div>

                    <div class="settings-section border-t border-gray-200 pt-4 mt-4">
                        <h3 class="element-title">Period Automation</h3>
                        <p class="description mb-3">Automatically generate future periods and approve past periods on page load.</p>
                        <div class="settings-parameter-group">
                            <div class="flex items-center mb-3">
                                <input type="checkbox" id="settingAutoGenerateEnabled" class="mr-2 h-4 w-4">
                                <label for="settingAutoGenerateEnabled" class="text-sm">Enable auto-generation of future periods</label>
                            </div>
                            <div class="settings-grid-item">
                                <label for="settingAutoGenerateMonthsAhead">Months ahead to auto-generate:</label>
                                <input type="number" id="settingAutoGenerateMonthsAhead" min="1" max="36" class="w-full">
                            </div>
                        </div>
                        <div class="mt-4 pt-4 border-t border-gray-100">
                            <h4 class="text-sm font-medium text-gray-700 mb-2">Bulk Generate Periods</h4>
                            <p class="description mb-2">Generate all 12 periods for a specific year (skips existing periods).</p>
                            <div class="flex gap-2 items-end">
                                <div>
                                    <label for="generateYearSelect" class="block text-sm text-gray-600 mb-1">Year:</label>
                                    <select id="generateYearSelect" class="py-2 px-3 border border-gray-300 rounded-md">
                                        <!-- Populated by JS -->
                                    </select>
                                </div>
                                <button onclick="generatePeriodsForYear(parseInt(document.getElementById('generateYearSelect').value))" class="btn-primary py-2 px-4">
                                    Generate Year
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="publicHolidays" class="tab-content">
                    <div class="settings-section">
                        <h3 class="element-title">Melbourne Public Holidays</h3>
                        <p class="description mb-2">Format: YYYY-MM-DD Holiday Name (one per line). Name is optional for tooltip.</p>
                        <textarea id="publicHolidaysTextSettings" class="w-full h-48" rows="10"></textarea>
                    </div>
                </div>

                <div id="calendar" class="tab-content">
                    <div class="settings-section">
                        <h3 class="element-title">Header Display Names</h3>
                        <div class="settings-parameter-group">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-4 gap-y-4"> <!-- Reduced gap-x -->
                                <div>
                                    <label for="spCutoffDisplay" class="block text-sm font-medium text-gray-700">SP Cutoff Text <span class="info-icon" data-tooltip-id="spCutoffDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="spCutoffDisplay" name="spCutoffDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., SP Cutoff (%M)">
                                </div>
                                <div>
                                    <label for="crewBidDisplay" class="block text-sm font-medium text-gray-700">Crew Bid Text <span class="info-icon" data-tooltip-id="crewBidDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="crewBidDisplay" name="crewBidDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., Crew Bid (%M)">
                                </div>
                                <div>
                                    <label for="spFeedbackDisplay" class="block text-sm font-medium text-gray-700">SP Feedback Text <span class="info-icon" data-tooltip-id="spFeedbackDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="spFeedbackDisplay" name="spFeedbackDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., SP Feedback (%M)">
                                </div>
                                <div>
                                    <label for="tradeOffDisplay" class="flex items-center text-sm font-medium text-gray-700">Trade Off Discussion Text <span class="info-icon ml-1" data-tooltip-id="tradeOffDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="tradeOffDisplay" name="tradeOffDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., Trade Off (%M)">
                                </div>
                                <div>
                                    <label for="ssimHandoverDisplay" class="block text-sm font-medium text-gray-700">SSIM Handover Text <span class="info-icon" data-tooltip-id="ssimHandoverDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="ssimHandoverDisplay" name="ssimHandoverDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., SSIM Handover (%M)">
                                </div>
                                <div>
                                    <label for="techCrewPublishDisplay" class="block text-sm font-medium text-gray-700">Tech Crew Publish Text <span class="info-icon" data-tooltip-id="techCrewPublishDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="techCrewPublishDisplay" name="techCrewPublishDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., Tech Publish (%M)">
                                </div>
                                <div>
                                    <label for="cabinCrewPublishDisplay" class="block text-sm font-medium text-gray-700">Cabin Crew Publish Text <span class="info-icon" data-tooltip-id="cabinCrewPublishDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="cabinCrewPublishDisplay" name="cabinCrewPublishDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., Cabin Publish (%M)">
                                </div>
                                <!-- New Header Display Name Inputs -->
                                <div>
                                    <label for="trainingHandoverDisplay" class="block text-sm font-medium text-gray-700">Training Handover Text <span class="info-icon" data-tooltip-id="trainingHandoverDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="trainingHandoverDisplay" name="trainingHandoverDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., Train H/O (%M)">
                                </div>
                                <div>
                                    <label for="cbPairingPublishTechDisplay" class="block text-sm font-medium text-gray-700">CB Pairing Publish Tech Text <span class="info-icon" data-tooltip-id="cbPairingPublishTechDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="cbPairingPublishTechDisplay" name="cbPairingPublishTechDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., CB Pub Tech (%M)">
                                </div>
                                <div>
                                    <label for="cbPairingPublishCabinDisplay" class="block text-sm font-medium text-gray-700">CB Pairing Publish Cabin Text <span class="info-icon" data-tooltip-id="cbPairingPublishCabinDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="cbPairingPublishCabinDisplay" name="cbPairingPublishCabinDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., CB Pub Cabin (%M)">
                                </div>
                                <div>
                                    <label for="biddingClosureTechDisplay" class="block text-sm font-medium text-gray-700">Bidding Closure Tech Text <span class="info-icon" data-tooltip-id="biddingClosureTechDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="biddingClosureTechDisplay" name="biddingClosureTechDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., Bid Close Tech (%M)">
                                </div>
                                <div>
                                    <label for="biddingClosureCabinDisplay" class="block text-sm font-medium text-gray-700">Bidding Closure Cabin Text <span class="info-icon" data-tooltip-id="biddingClosureCabinDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="biddingClosureCabinDisplay" name="biddingClosureCabinDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., Bid Close Cabin">
                                </div>
                                <div>
                                    <label for="rosterBuildCommenceTechDisplay" class="block text-sm font-medium text-gray-700">Roster Build Tech Text <span class="info-icon" data-tooltip-id="rosterBuildCommenceTechDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="rosterBuildCommenceTechDisplay" name="rosterBuildCommenceTechDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., RosterBuild Tech (%M)">
                                </div>
                                <div>
                                    <label for="rosterBuildCommenceCabinDisplay" class="block text-sm font-medium text-gray-700">Roster Build Cabin Text <span class="info-icon" data-tooltip-id="rosterBuildCommenceCabinDisplayTooltip">&#9432;</span></label>
                                    <input type="text" id="rosterBuildCommenceCabinDisplay" name="rosterBuildCommenceCabinDisplay" class="mt-1 block w-full py-2 px-3 border border-gray-300 bg-white rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm" placeholder="e.g., RosterBuild Cabin (%M)">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="settings-section">
                        <h3 class="element-title">Color Themes</h3>
                        <div class="settings-parameter-group">
                            <div class="settings-grid-item mb-4">
                                <label for="planningColorSetting" class="block mb-1">Planning Color</label>
                                <input type="color" id="planningColorSetting" value="#cfe2f3" class="w-full h-10 p-1 border rounded-md">
                            </div>
                            <div class="settings-grid-item mb-4">
                                <label for="publishColorSetting" class="block mb-1">Publish Color</label>
                                <input type="color" id="publishColorSetting" value="#fff2cc" class="w-full h-10 p-1 border rounded-md">
                            </div>
                            <div class="settings-grid-item mb-4">
                                <label for="holidayColorSetting" class="block mb-1">Public Holiday Color</label>
                                <input type="color" id="holidayColorSetting" value="#d9ead3" class="w-full h-10 p-1 border rounded-md">
                            </div>
                            <!-- New Color Picker Inputs -->
                            <div class="settings-grid-item mb-4">
                                <label for="trainingHandoverColorSetting" class="block mb-1">Training Handover Color</label>
                                <input type="color" id="trainingHandoverColorSetting" value="#e9d5ff" class="w-full h-10 p-1 border rounded-md">
                            </div>
                            <div class="settings-grid-item mb-4">
                                <label for="cbPairingPublishColorSetting" class="block mb-1">CB Pairing Publish Color</label>
                                <input type="color" id="cbPairingPublishColorSetting" value="#99f6e4" class="w-full h-10 p-1 border rounded-md">
                            </div>
                            <div class="settings-grid-item mb-4">
                                <label for="biddingClosureColorSetting" class="block mb-1">Bidding Closure Color</label>
                                <input type="color" id="biddingClosureColorSetting" value="#fed7aa" class="w-full h-10 p-1 border rounded-md">
                            </div>
                            <div class="settings-grid-item mb-4">
                                <label for="rosterBuildCommenceColorSetting" class="block mb-1">Roster Build Commence Color</label>
                                <input type="color" id="rosterBuildCommenceColorSetting" value="#bbf7d0" class="w-full h-10 p-1 border rounded-md">
                            </div>
                        </div>
                    </div>
                </div>

                <div id="rosterDefinitions" class="tab-content">
                    <div class="settings-section">
                        <div class="flex justify-between items-center mb-3">
                            <h3 class="element-title">Standard Roster Periods</h3>
                            <div class="flex items-center space-x-2">
                                <button onclick="changeRosterReferenceYear(-1)" title="Previous Year" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-1 px-3 rounded-md shadow-sm text-sm">&larr;</button>
                                <span id="rosterReferenceYearDisplay" class="font-medium text-lg"></span>
                                <button onclick="changeRosterReferenceYear(1)" title="Next Year" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-semibold py-1 px-3 rounded-md shadow-sm text-sm">&rarr;</button>
                            </div>
                        </div>
                        <div class="table-responsive">
                            <table class="min-w-full divide-y divide-gray-200 text-sm">
                                <thead class="bg-gray-100">
                                    <tr>
                                        <th class="px-3 py-2 text-left font-medium text-gray-600 uppercase tracking-wider">Roster Period</th>
                                        <th class="px-3 py-2 text-left font-medium text-gray-600 uppercase tracking-wider">Start Date</th>
                                        <th class="px-3 py-2 text-left font-medium text-gray-600 uppercase tracking-wider">End Date</th>
                                        <th class="px-3 py-2 text-left font-medium text-gray-600 uppercase tracking-wider">Days</th>
                                    </tr>
                                </thead>
                                <tbody id="rosterPeriodsReferenceBody" class="bg-white divide-y divide-gray-200"></tbody>
                            </table>
                        </div>
                    </div>
                </div>

                <div id="addBidPeriodTab" class="tab-content">
                    <div class="settings-section">
                        <h3 class="element-title">Add New Bid Period</h3>
                        <div id="bidPeriodInput" class="space-y-4 settings-parameter-group">
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                <div>
                                    <label for="selectBidYear" class="block text-sm font-medium text-gray-700 mb-1">Select Year:</label>
                                    <select id="selectBidYear" class="w-full"></select>
                                </div>
                                <div>
                                    <label for="selectBidMonth" class="block text-sm font-medium text-gray-700 mb-1">Select Bid Month:</label>
                                    <select id="selectBidMonth" class="w-full"></select>
                                </div>
                            </div>
                            <div>
                                <label for="spCutoffDate" class="block text-sm font-medium text-gray-700 mb-1">SP Cutoff Date (Suggested; override if needed):</label>
                                <input type="date" id="spCutoffDate" class="w-full">
                            </div>
                            <div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-2">
                                <button onclick="autoAddAndCalculateNextBidPeriod()" class="w-full sm:w-1/2 bg-teal-600 hover:bg-teal-700 text-white font-semibold py-2 px-4 rounded-md shadow-md">
                                    Auto-Add Next Period
                                </button>
                                <button onclick="addBidPeriodFromForm()" class="w-full sm:w-1/2 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md shadow-md">
                                    Add Manually (Selected Month)
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

            </div>

            <div id="recalculationNotice" class="text-sm text-gray-600 mt-4"></div>

            <div class="mt-6 flex justify-end gap-3">
                <button onclick="cancelSettings()" class="btn-secondary">Cancel</button>
                <button onclick="saveSettings()" class="btn-primary">Save Changes</button>
            </div>
        </div>
    </div>

    <div id="mainPage">
        <div class="bg-white p-6 md:p-8 rounded-xl shadow-xl">
            <header class="mb-8 text-center relative page-section-constrained" style="background-color: var(--navy-primary); color: white; padding-top: 1.5rem; padding-bottom: 1.5rem; border-radius: 0.75rem;">
                <h1 class="text-3xl md:text-4xl font-bold" style="color: white;">WFP Schedule Planner</h1>
                <button onclick="showPage('settingsPage')" title="Go to Settings" class="absolute top-0 right-0 text-2xl p-2" style="color: white; opacity: 0.8;">&#9881;</button>
            </header>

            <!-- Toast message div moved to be a direct child of body -->

            <div class="page-section-constrained"> 
                <!-- Quick Actions and Add New Bid Period sections removed from here and moved to Settings -->
            </div>
            
            <div class="page-section-constrained"> <div class="bg-white p-0 md:p-6 rounded-lg shadow-lg mb-4">
                    <div class="flex justify-between items-center mb-6">
                        <h2 class="text-2xl font-semibold text-gray-800 text-center md:text-left">SSIM Handover Dates</h2>
                        <!-- Button removed as per Request 4 -->
                        <div class="relative">
                            <button id="exportSsimCsvBtn" class="btn-secondary py-1 px-3 text-sm">
                                Export CSV
                                <svg class="w-2.5 h-2.5 ms-3 inline-block" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6">
                                    <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m1 1 4 4 4-4"/>
                                </svg>
                            </button>
                            <div id="exportSsimOptions" class="absolute right-0 z-10 mt-2 w-48 bg-white rounded-md shadow-lg ring-1 ring-black ring-opacity-5 hidden">
                                <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="exportSsimCsvBtn">
                                    <a href="#" id="exportViewableCsv" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">Export Viewable Period</a>
                                    <a href="#" id="exportAllCsv" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100" role="menuitem">Export All Data</a>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2 mb-4">
                        <button id="ssimTablePrevMonthBtn" class="btn-secondary py-1 px-3 text-sm">&larr; Previous Month</button>
                        <span id="ssimTableDateRangeDisplay" class="flex-grow text-center text-sm font-semibold text-gray-700"></span>
                        <button id="ssimTableNextMonthBtn" class="btn-secondary py-1 px-3 text-sm">Next Month &rarr;</button>
                    </div>
                    <div class="table-responsive">
                        <table class="min-w-full divide-y divide-gray-200">
                            <thead class="bg-gray-100">
                                <tr>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">Bid Period</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">SP Cutoff</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">SP Feedback</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">Trade Off Discussion</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">Final SSIM Handover</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">Tech Crew Publish</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">Cabin Crew Publish</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">Approval Status</th>
                                    <th class="px-4 py-3 text-left text-xs font-medium text-gray-600 uppercase tracking-wider">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="resultsBody" class="bg-white divide-y divide-gray-200"></tbody>
                        </table>
                    </div>
                    <p id="noResultsMessage" class="text-center text-gray-500 py-8">No bid periods added yet.</p>
                </div>
            </div>

            <div id="calendarViewSection" class="bg-white p-0 md:p-6 rounded-lg shadow-lg border border-[var(--navy-light-lighter)]">
                <!-- Title Bar -->
                <div class="page-section-constrained mb-4">
                    <h2 class="text-2xl font-semibold text-gray-800 py-2 border-b border-[var(--navy-light)] text-center">Calendar Overview</h2>
                </div>

                <!-- Controls and Legend Row -->
                <div class="page-section-constrained mb-4 flex flex-col sm:flex-row justify-between items-center">
                    <!-- Legend -->
                    <div class="border border-[var(--navy-light)] rounded-md p-3 mb-4 sm:mb-0" style="width: max-content;" id="calendarLegend">
                        <!-- Legend content generated by JS -->
                    </div>
                    <!-- Navigation/Zoom Controls -->
                    <div class="flex space-x-2 items-center">
                        <button id="prevMonthBtn" title="Previous Month" aria-label="Previous Month" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold p-2 rounded-md shadow-sm flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" />
                            </svg>
                        </button>
                        <button id="nextMonthBtn" title="Next Month" aria-label="Next Month" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold p-2 rounded-md shadow-sm flex items-center justify-center">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" />
                            </svg>
                        </button>
                        <span class="mx-2 text-gray-400">|</span>
                        <!-- Zoom Toggle Switch -->
                        <div class="flex items-center space-x-2">
                            <span class="text-sm font-medium text-gray-700 select-none" id="zoomToggleLabelStandard">Standard</span>
                            <label class="relative inline-flex items-center cursor-pointer">
                                <input type="checkbox" id="calendarZoomToggle" class="sr-only peer">
                                <div class="w-11 h-6 bg-gray-300 peer-focus:outline-none peer-focus:ring-2 peer-focus:ring-[var(--navy-primary)] rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-[var(--navy-primary)]"></div>
                            </label>
                            <span class="text-sm font-medium text-gray-700 select-none" id="zoomToggleLabelCompact">Compact</span>
                        </div>
                        <span class="mx-2 text-gray-400">|</span>
                        <!-- Event Type Filter Dropdown -->
                        <div class="relative">
                            <button id="eventFilterBtn" class="btn-secondary py-1 px-3 text-sm !mb-0">
                                Filter Events
                                <svg class="w-2.5 h-2.5 ms-2 inline-block" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 10 6">
                                    <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m1 1 4 4 4-4"/>
                                </svg>
                            </button>
                            <div id="eventFilterDropdown" class="hidden absolute right-0 mt-2 w-64 bg-white rounded-md shadow-xl z-20 border border-[var(--navy-light)] p-4 space-y-2">
                                <!-- Checkboxes will be populated by JS -->
                            </div>
                        </div>
                    </div>
                </div>
                
                <div id="calendarGridWrapper" class="calendar-grid-container-wrapper calendar-zoom-0">
                    <div id="calendarGridContainer" class="calendar-grid-container" role="grid">
                        </div>
                </div>
                 <p id="noCalendarDataMessage" class="text-center text-gray-500 py-8 page-section-constrained">Add bid periods to see the calendar overview.</p>
            </div>
        </div>
    </div>

    <!-- Removed duplicate/erroneous settingsPage div that was here -->

    <div id="editModalOverlay" class="modal-overlay">
        <div class="modal-content">
            <!-- Banner Style Title - Aligned with theme -->
            <h3 class="text-xl font-semibold p-3 bg-[var(--navy-light)] text-[var(--navy-primary)] rounded-t-md -mx-[1.5rem] -mt-[1.5rem] mb-6 text-center" id="editModalTitle">Edit Bid Period Dates</h3>
            
            <input type="hidden" id="editPeriodId">
            <input type="hidden" id="editBidPeriodNameHidden"> 
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-4"> 
                <div><label for="editRosterStartDate">Roster Start Date:</label><input type="date" id="editRosterStartDate"></div>
                <div><label for="editRosterEndDate">Roster End Date:</label><input type="date" id="editRosterEndDate"></div>
                
                <div><label for="editSpCutoffDate">SP Cutoff Date:</label><input type="date" id="editSpCutoffDate"></div>
                <div><label for="editSpFeedbackDate">SP Feedback Date:</label><input type="date" id="editSpFeedbackDate"></div>

                <div><label for="editTradeOffDiscussionDate">Trade Off Discussion Date:</label><input type="date" id="editTradeOffDiscussionDate"></div>
                <div><label for="editFinalSSIMHandoverDate">Final SSIM Handover Date:</label><input type="date" id="editFinalSSIMHandoverDate"></div>
                <div><label for="editTechCrewPublishDate">Tech Crew Publish Date:</label><input type="date" id="editTechCrewPublishDate"></div>
                <div><label for="editCabinCrewPublishDate">Cabin Crew Publish Date:</label><input type="date" id="editCabinCrewPublishDate"></div>
                
                <div class="md:col-span-2 mt-2">
                    <label class="block text-sm font-medium text-gray-700 mb-2">Approval Status:</label>
                    <input type="hidden" id="editApprovalStatus" value="Pending">
                    <div class="flex gap-2">
                        <button type="button" id="statusBtnPending" onclick="setApprovalStatus('Pending')" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 border-2">
                            Pending
                        </button>
                        <button type="button" id="statusBtnApproved" onclick="setApprovalStatus('Approved')" class="flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 border-2">
                            Approved
                        </button>
                    </div>
                </div>
            </div>

            <div class="mt-6 flex flex-col gap-4">
                <!-- Collapsible Recalculate Tools Section -->
                <div class="border-t border-gray-200 pt-3">
                    <button type="button" onclick="toggleRecalculateTools()" class="flex items-center gap-2 text-sm text-gray-500 hover:text-gray-700 transition-colors w-full">
                        <span id="recalcToolsIcon" class="text-xs transition-transform duration-200"></span>
                        <span> Recalculate Tools</span>
                    </button>
                    <div id="recalculateToolsContent" class="hidden mt-3">
                        <div class="bg-gray-50 rounded-lg p-3 space-y-3">
                            <div>
                                <button onclick="recalculateDatesInModal()" class="w-full bg-[var(--orange-accent)] hover:bg-orange-700 text-white font-semibold py-2 px-3 rounded-md text-sm">
                                     Forward from SP Cutoff
                                </button>
                                <p class="text-xs text-gray-500 mt-1 text-center">Calculates: SP Feedback  Trade Off  SSIM Handover  Publish dates</p>
                            </div>
                            <div>
                                <button onclick="recalculateBackwardFromSSIM()" class="w-full bg-[var(--navy-primary)] hover:bg-blue-900 text-white font-semibold py-2 px-3 rounded-md text-sm">
                                    Backward from SSIM Handover 
                                </button>
                                <p class="text-xs text-gray-500 mt-1 text-center">Calculates: Trade Off  SP Feedback  SP Cutoff</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Delete / Cancel / Save -->
                <div class="flex justify-between items-center border-t border-gray-200 pt-4">
                    <button onclick="deleteBidPeriod()" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-md text-sm">Delete</button>
                    <div class="flex gap-3">
                        <button onclick="closeEditModal()" class="btn-secondary py-2 px-4">Cancel</button>
                        <button onclick="saveEditedDates()" class="btn-primary py-2 px-4">Save Changes</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="toast-message"></div> <!-- Toast message div moved here, before the script tag -->
    <script>
        // Global State
        window.allBidPeriodData = window.allBidPeriodData || [];
        const standardRosterPeriods = [
            { name: 'January', startDay: 1, startMonth: 0, days: 31 },
            { name: 'February', startDay: 1, startMonth: 1, days: 28 },
            { name: 'March', startDay: 1, startMonth: 2, days: 31 },
            { name: 'April', startDay: 1, startMonth: 3, days: 30 },
            { name: 'May', startDay: 1, startMonth: 4, days: 31 },
            { name: 'June', startDay: 1, startMonth: 5, days: 30 },
            { name: 'July', startDay: 1, startMonth: 6, days: 31 },
            { name: 'August', startDay: 1, startMonth: 7, days: 31 },
            { name: 'September', startDay: 1, startMonth: 8, days: 30 },
            { name: 'October', startDay: 1, startMonth: 9, days: 31 },
            { name: 'November', startDay: 1, startMonth: 10, days: 30 },
            { name: 'December', startDay: 1, startMonth: 11, days: 31 }
        ];
        // --- Initialization Functions ---

        function saveBidPeriodData() {
            try {
                localStorage.setItem('bidPeriodData', JSON.stringify(allBidPeriodData));
                console.log('DEBUG: saveBidPeriodData - Successfully saved to localStorage.');
            } catch (e) {
                console.error('Error saving bid period data to localStorage:', e);
                showToast('Warning: Could not save data locally. Storage might be full.', 4000);
            }
        }

        function initializeAppSettings() {
            const defaultSettings = {
                spCutoffRule: {
                    day: 10,
                    monthsPrior: 2,
                    weekendAdjustment: 'nextWorkingDay'
                },
                eventTypeVisibility: { 
                    spCutoff: true,
                    spFeedback: true,
                    tradeOffDiscussion: true,
                    finalSSIMHandover: true,
                    techCrewPublish: true,
                    cabinCrewPublish: true,
                    publicHoliday: true,
                    // New event visibilities
                    trainingHandoverTech: true,
                    trainingHandoverCabin: true,
                    cbPairingPublishTech: true,
                    cbPairingPublishCabin: true,
                    biddingClosureTech: true,
                    biddingClosureCabin: true,
                    rosterBuildCommenceTech: true,
                    rosterBuildCommenceCabin: true
                },
                spFeedbackOffset: 5,
                tradeOffOffset: 3,
                ssimHandoverOffset: 2,
                ssimFridayRule: false, 
                techCrewPublishOffset: 10, 
                cabinCrewPublishOffset: 7,
                // New Calculation Parameters
                trainingHandoverOffset: 7,          // Default: 7 calendar days AFTER Final SSIM Handover
                cbPairingPublishTechOffset: -5,     // Default: 5 working days BEFORE Bidding Closure Tech
                cbPairingPublishCabinOffset: -5,    // Default: 5 working days BEFORE Bidding Closure Cabin
                biddingClosureTechOffset: -5,       // Default: 5 calendar days BEFORE Roster Build Commence Tech
                biddingClosureCabinOffset: -5,      // Default: 5 calendar days BEFORE Roster Build Commence Cabin
                rosterBuildCommenceTechOffset: -5,  // Default: 5 calendar days BEFORE Tech Crew Publish
                rosterBuildCommenceCabinOffset: -5, // Default: 5 calendar days BEFORE Cabin Crew Publish
                // Auto-generation settings
                autoGenerateEnabled: true,          // Enable auto-generation of future periods
                autoGenerateMonthsAhead: 18,        // How many months ahead to auto-generate
                colors: {
                    planning: '#e0f2fe',
                    publish: '#fef9c3',
                    holiday: '#f3f4f6',
                    // New event group colors
                    trainingHandoverColor: '#e9d5ff',    // Light Purple
                    cbPairingPublishColor: '#99f6e4',    // Light Teal
                    biddingClosureColor: '#fed7aa',      // Light Orange
                    rosterBuildCommenceColor: '#bbf7d0'  // Light Green
                },
                headerDisplayNames: {
                    spCutoff: 'SP CUTOFF',
                    crewBid: 'CREW BID', // Keep existing even if not a primary eventType key
                    spFeedback: 'SP Fback (%M)',
                    tradeOffDiscussion: 'TradeOff (%M)',
                    finalSSIMHandover: 'SSIM H/O (%M)',
                    techCrewPublish: 'Tech Pub (%M)',
                    cabinCrewPublish: 'Cabin Pub (%M)',
                    // New event header names
                    trainingHandoverTech: 'Train H/O Tech (%M)',
                    trainingHandoverCabin: 'Train H/O Cabin (%M)',
                    cbPairingPublishTech: 'CB Pub Tech (%M)',
                    cbPairingPublishCabin: 'CB Pub Cabin (%M)',
                    biddingClosureTech: 'Bid Close Tech (%M)',
                    biddingClosureCabin: 'Bid Close Cabin (%M)', // Added (%M) placeholder
                    rosterBuildCommenceTech: 'RosterBuild Tech (%M)',
                    rosterBuildCommenceCabin: 'RosterBuild Cabin (%M)'
                }
            };

            const savedSettings = localStorage.getItem('appSettings');
            window.appSettings = savedSettings ? JSON.parse(savedSettings) : { ...defaultSettings }; // Use spread for a fresh copy

            // Deep merge for nested objects like eventTypeVisibility, colors, headerDisplayNames, and spCutoffRule
            if (savedSettings) {
                const loadedSettings = JSON.parse(savedSettings);
                
                // Merge eventTypeVisibility
                window.appSettings.eventTypeVisibility = { 
                    ...defaultSettings.eventTypeVisibility, 
                    ...(loadedSettings.eventTypeVisibility || {}) 
                };
                // Merge colors
                window.appSettings.colors = { 
                    ...defaultSettings.colors, 
                    ...(loadedSettings.colors || {}) 
                };
                // Merge headerDisplayNames
                window.appSettings.headerDisplayNames = { 
                    ...defaultSettings.headerDisplayNames, 
                    ...(loadedSettings.headerDisplayNames || {}) 
                };
                 // Merge spCutoffRule
                window.appSettings.spCutoffRule = { 
                    ...defaultSettings.spCutoffRule, 
                    ...(loadedSettings.spCutoffRule || {}) 
                };

                // Ensure all other top-level default keys are present
                for (const key in defaultSettings) {
                    if (typeof window.appSettings[key] === 'undefined') {
                        window.appSettings[key] = defaultSettings[key];
                    }
                }
            }


            // Initialize settings form
            // No need to save here if it's just loaded or defaulted, save happens in saveSettings()
            document.getElementById('settingSpCutoffDay').value = appSettings.spCutoffRule.day;
            document.getElementById('settingSpCutoffMonthsPrior').value = appSettings.spCutoffRule.monthsPrior;
            document.getElementById('settingSpCutoffWeekendAdjust').value = appSettings.spCutoffRule.weekendAdjustment;
            document.getElementById('settingSpFeedbackOffset').value = appSettings.spFeedbackOffset;
            document.getElementById('settingTradeOffOffset').value = appSettings.tradeOffOffset;
            document.getElementById('settingSsimHandoverOffset').value = appSettings.ssimHandoverOffset;
            document.getElementById('settingSsimFridayRule').checked = appSettings.ssimFridayRule;
            document.getElementById('settingTechCrewPublishOffset').value = appSettings.techCrewPublishOffset;
            document.getElementById('settingCabinCrewPublishOffset').value = appSettings.cabinCrewPublishOffset;

            // Auto-generation settings - ensure boolean value exists
            if (typeof appSettings.autoGenerateEnabled !== 'boolean') {
                appSettings.autoGenerateEnabled = true; // Default to enabled
            }
            document.getElementById('settingAutoGenerateEnabled').checked = appSettings.autoGenerateEnabled;
            document.getElementById('settingAutoGenerateMonthsAhead').value = appSettings.autoGenerateMonthsAhead || 18;

            // Populate generate year dropdown
            populateGenerateYearDropdown();
        }

        function populateGenerateYearDropdown() {
            const select = document.getElementById('generateYearSelect');
            if (!select) return;

            const currentYear = new Date().getFullYear();
            select.innerHTML = '';

            for (let year = currentYear; year <= currentYear + 3; year++) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                select.appendChild(option);
            }
        }

        // --- Settings Navigation Functions ---
        function openSettings() {
            document.getElementById('mainPage').style.display = 'none';
            document.getElementById('settingsPage').style.display = 'block';
            initializeSettingsPage();
        }

        function cancelSettings() {
            document.getElementById('mainPage').style.display = 'block';
            document.getElementById('settingsPage').style.display = 'none';
        }

        // --- Global Variables & Constants ---
        let melbournePublicHolidays = [];
        let calendarMonthsToDisplay = 6; // Default to 6 months
        let calendarViewStartDate; 
        let rosterReferenceCurrentYear = new Date().getFullYear();
        
        // Calendar Zoom Functionality
        let currentCalendarZoomLevel = 0; // 0: Standard, 1: Compact
        const calendarZoomLevels = [
            { dayColMin: '50px' }, // Level 0 (Standard)
            { dayColMin: '40px' }  // Level 1 (Compact)
        ];
        const CALENDAR_ZOOM_STORAGE_KEY = 'calendarZoomLevel';

        const SATURDAY = 6;
        const SUNDAY = 0;
        const FRIDAY = 5; 
        const monthMap = { 'Jan': 0, 'Feb': 1, 'Mar': 2, 'Apr': 3, 'May': 4, 'Jun': 5, 'Jul': 6, 'Aug': 7, 'Sep': 8, 'Oct': 9, 'Nov': 10, 'Dec': 11 };
        const monthNames = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
        const eventTypes = {
            // Original Events
            spCutoff: {
                label: "SP Cutoff",
                color: "#e0f2fe",
                type: "planning",
                displayOrder: 1,
                displayInCalendar: true,
                displayInTable: true
            },
            spFeedback: {
                label: "SP Fback",
                color: "#e0f2fe",
                type: "planning",
                displayOrder: 2,
                displayInCalendar: true,
                displayInTable: true
            },
            tradeOffDiscussion: {
                label: "TradeOff",
                color: "#e0f2fe",
                type: "planning",
                displayOrder: 3,
                displayInCalendar: true,
                displayInTable: true
            },
            finalSSIMHandover: {
                label: "SSIM H/O",
                color: "#e0f2fe",
                type: "planning",
                displayOrder: 4,
                displayInCalendar: true,
                displayInTable: true
            },
            techCrewPublish: {
                label: "Tech Pub",
                color: "#fef9c3",
                type: "publish",
                displayOrder: 5,
                displayInCalendar: true,
                displayInTable: true
            },
            cabinCrewPublish: {
                label: "Cabin Pub",
                color: "#fef9c3",
                type: "publish",
                displayOrder: 6,
                displayInCalendar: true,
                displayInTable: true
            },
            
            // Phase 2 - Training Handover
            trainingHandoverTech: {
                label: "Train H/O Tech",
                color: "#e9d5ff",
                type: "training",
                displayOrder: 7,
                displayInCalendar: true,
                displayInTable: true
            },
            trainingHandoverCabin: {
                label: "Train H/O Cabin",
                color: "#e9d5ff",
                type: "training",
                displayOrder: 8,
                displayInCalendar: true,
                displayInTable: true
            },
            
            // Phase 2 - Roster Build Commence
            rosterBuildCommenceTech: {
                label: "Roster Build Start Tech",
                color: "#bbf7d0",
                type: "roster",
                displayOrder: 9,
                displayInCalendar: true,
                displayInTable: true
            },
            rosterBuildCommenceCabin: {
                label: "Roster Build Start Cabin",
                color: "#bbf7d0",
                type: "roster",
                displayOrder: 10,
                displayInCalendar: true,
                displayInTable: true
            },
            
            // Phase 2 - Bidding Closure
            biddingClosureTech: {
                label: "Bid Close Tech",
                color: "#fed7aa",
                type: "bidding",
                displayOrder: 11,
                displayInCalendar: true,
                displayInTable: true
            },
            biddingClosureCabin: {
                label: "Bid Close Cabin",
                color: "#fed7aa",
                type: "bidding",
                displayOrder: 12,
                displayInCalendar: true,
                displayInTable: true
            },
            
            // Phase 2 - CB Pairing Publish
            cbPairingPublishTech: {
                label: "CB Pairs Pub Tech",
                color: "#99f6e4",
                type: "pairing",
                displayOrder: 13,
                displayInCalendar: true,
                displayInTable: true
            },
            cbPairingPublishCabin: {
                label: "CB Pairs Pub Cabin",
                color: "#99f6e4",
                type: "pairing",
                displayOrder: 14,
                displayInCalendar: true,
                displayInTable: true
            }
        };
        const cellHighlightClasses = {
            publish: "publish",
            planning: "planning",
            publicHoliday: "publicHoliday"
        };

        let appSettings = {
            // Phase 1 Settings
            spCutoffRule: { day: 10, monthsPrior: 2, weekendAdjustment: 'nextWorkingDay' },
            spFeedbackOffset: 2, 
            tradeOffOffset: 1, 
            ssimHandoverOffset: 1, 
            ssimFridayRule: false, 
            techCrewPublishOffset: 10, 
            cabinCrewPublishOffset: 7,
            
            // Phase 2 - Training Handover
            trainingHandoverOffset: 7,  // 7 working days after SSIM Handover
            
            // Phase 2 - Roster Build Commence
            rosterBuildCommenceTechOffset: -12,  // 12 working days before Tech Publish
            rosterBuildCommenceCabinOffset: -16, // 16 working days before Cabin Publish
            
            // Phase 2 - Bidding Closure
            biddingClosureTechOffset: -1,  // 1 working day before Roster Build Commence (Tech)
            biddingClosureCabinDay: 'first-tuesday', // First Tuesday of the month
            
            // Phase 2 - CB Pairing Publish
            cbPairingPublishTechOffset: -2,  // 2 working days before Bidding Closure (Tech)
            cbPairingPublishCabinDay: 'last-friday' // Last Friday of the month
        };


        const staticReferenceDataSource = [
            { bid: "Dec-24", spc: "11/10/24", spf: "15/10/24", tod: "16/10/24", ssim: "17/10/24", tcp: "20/11/24", ccp: "22/11/24" },
            { bid: "Jan-25", spc: "11/11/24", spf: "13/11/24", tod: "14/11/24", ssim: "15/11/24", tcp: "20/12/24", ccp: "24/12/24" },
            { bid: "Feb-25", spc: "03/12/24", spf: "05/12/24", tod: "06/12/24", ssim: "09/12/24", tcp: "21/01/25", ccp: "24/01/25" },
            { bid: "Mar-25", spc: "13/01/25", spf: "15/01/25", tod: "16/01/25", ssim: "17/01/25", tcp: "19/02/25", ccp: "21/02/25" },
            { bid: "Apr-25", spc: "07/02/25", spf: "11/02/25", tod: "12/02/25", ssim: "13/02/25", tcp: "21/03/25", ccp: "24/03/25" },
            { bid: "May-25", spc: "10/03/25", spf: "12/03/25", tod: "13/03/25", ssim: "14/03/25", tcp: "17/04/25", ccp: "23/04/25" },
            { bid: "Jun-25", spc: "11/04/25", spf: "15/04/25", tod: "16/04/25", ssim: "17/04/25", tcp: "21/05/25", ccp: "23/05/25" },
            { bid: "Jul-25", spc: "12/05/25", spf: "14/05/25", tod: "15/05/25", ssim: "16/05/25", tcp: "20/06/25", ccp: "23/06/25" },
            { bid: "Aug-25", spc: "11/06/25", spf: "13/06/25", tod: "16/06/25", ssim: "17/06/25", tcp: "21/07/25", ccp: "24/07/25" },
            { bid: "Sep-25", spc: "11/07/25", spf: "15/07/25", tod: "16/07/25", ssim: "17/07/25", tcp: "21/08/25", ccp: "22/08/25" },
            { bid: "Oct-25", spc: "13/08/25", spf: "15/08/25", tod: "18/08/25", ssim: "19/08/25", tcp: "19/09/25", ccp: "23/09/25" }
        ];
        
        const standardRosterPeriodDefinitions = [ 
            { period: "Jan", startRule: (year) => `${year}-01-01`, endRule: (year) => `${year}-01-30`, days: "30" },
            { period: "Feb", startRule: (year) => `${year}-01-31`, endRule: (year) => `${year}-03-01`, days: (year) => new Date(year, 1, 29).getDate() === 29 ? "30/31 (leap)" : "30" },
            { period: "Mar", startRule: (year) => `${year}-03-02`, endRule: (year) => `${year}-03-31`, days: "30" },
            { period: "Apr", startRule: (year) => `${year}-04-01`, endRule: (year) => `${year}-04-30`, days: "30" },
            { period: "May", startRule: (year) => `${year}-05-01`, endRule: (year) => `${year}-05-31`, days: "31" },
            { period: "Jun", startRule: (year) => `${year}-06-01`, endRule: (year) => `${year}-06-30`, days: "30" },
            { period: "Jul", startRule: (year) => `${year}-07-01`, endRule: (year) => `${year}-07-31`, days: "31" },
            { period: "Aug", startRule: (year) => `${year}-08-01`, endRule: (year) => `${year}-08-31`, days: "31" },
            { period: "Sep", startRule: (year) => `${year}-09-01`, endRule: (year) => `${year}-09-30`, days: "30" },
            { period: "Oct", startRule: (year) => `${year}-10-01`, endRule: (year) => `${year}-10-31`, days: "31" },
            { period: "Nov", startRule: (year) => `${year}-11-01`, endRule: (year) => `${year}-11-30`, days: "30" },
            { period: "Dec", startRule: (year) => `${year}-12-01`, endRule: (year) => `${year}-12-31`, days: "31" }
        ];

        let currentHolidayTooltip = null; 
        let currentEventTooltip = null;


        // --- Toast Notification ---
        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast-message');
            if (!toast) return;
            toast.textContent = message;
            toast.classList.add('show');
            if (toast.timeoutId) clearTimeout(toast.timeoutId);
            toast.timeoutId = setTimeout(() => {
                toast.classList.remove('show');
                toast.classList.add('hide');
                 setTimeout(() => toast.classList.remove('hide'), 500);
            }, duration);
        }

        // --- Page Navigation ---
        function showPage(pageId) {
            document.getElementById('mainPage').style.display = 'none';
            document.getElementById('settingsPage').style.display = 'none';
            document.getElementById(pageId).style.display = 'block';
            if (pageId === 'settingsPage') {
                initializeSettingsPage(); 
            }
        }


        // --- Public Holidays ---
        function initializePublicHolidays() {
            const defaultHolidaysData = [
                { date: "2025-01-01", name: "New Year" }, { date: "2025-01-27", name: "Aus Day" },
                { date: "2025-03-10", name: "Labour Day" }, { date: "2025-04-18", name: "Good Fri" },
                { date: "2025-04-21", name: "Easter Mon" }, { date: "2025-04-25", name: "ANZAC Day" },
                { date: "2025-06-09", name: "King's Bday" }, { date: "2025-09-26", name: "AFL Fri (Est)" },
                { date: "2025-11-04", name: "Melb Cup" }, { date: "2025-12-25", name: "Xmas Day" },
                { date: "2025-12-26", name: "Boxing Day" },
                { date: "2026-01-01", name: "New Year" }, { date: "2026-01-26", name: "Aus Day" },
                { date: "2026-03-09", name: "Labour Day" }, { date: "2026-04-03", name: "Good Fri" },
                { date: "2026-04-06", name: "Easter Mon" }, { date: "2026-04-25", name: "ANZAC Day" }, 
                { date: "2026-04-27", name: "ANZAC Day (Obs)" }, 
                { date: "2026-06-08", name: "King's Bday" }, { date: "2026-09-25", name: "AFL Fri (Est)" },
                { date: "2026-11-03", name: "Melb Cup" }, { date: "2026-12-25", name: "Xmas Day" },
                { date: "2026-12-28", name: "Boxing Day (Obs)" },
                { date: "2027-01-01", name: "New Year" }, { date: "2027-01-26", name: "Aus Day" },
                { date: "2027-03-08", name: "Labour Day" }, { date: "2027-03-26", name: "Good Fri" },
                { date: "2027-03-29", name: "Easter Mon" }, { date: "2027-04-25", name: "ANZAC Day" }, 
                { date: "2027-04-26", name: "ANZAC Day (Obs)" },
                { date: "2027-06-14", name: "King's Bday" }, { date: "2027-09-24", name: "AFL Fri (Est)" },
                { date: "2027-11-02", name: "Melb Cup" }, { date: "2027-12-27", name: "Xmas Day (Obs)" }, 
                { date: "2027-12-28", name: "Boxing Day (Obs)" } 
            ];

            const storedHolidaysText = localStorage.getItem('melbournePublicHolidaysText');
            const holidaysTextarea = document.getElementById('publicHolidaysTextSettings'); 
            if (storedHolidaysText) {
                 parsePublicHolidaysText(storedHolidaysText); 
                 holidaysTextarea.value = storedHolidaysText;
            } else {
                 melbournePublicHolidays = defaultHolidaysData;
                 const defaultHolidaysText = defaultHolidaysData.map(h => `${h.date} ${h.name}`).join('\n');
                 holidaysTextarea.value = defaultHolidaysText;
                 localStorage.setItem('melbournePublicHolidaysText', defaultHolidaysText);
                 console.log('DEBUG: initializePublicHolidays - Default holidays saved to localStorage.');
            }
        }
        
        function parsePublicHolidaysText(text) {
            melbournePublicHolidays = text.split('\n')
                .map(line => line.trim())
                .filter(line => line)
                .map(line => {
                    const parts = line.match(/^(\d{4}-\d{2}-\d{2})\s*(.*)$/);
                    if (parts) {
                        return { date: parts[1], name: parts[2].trim() || "Public Holiday" };
                    }
                    return null; 
                })
                .filter(Boolean); 
        }


        function updatePublicHolidays() {
            const text = document.getElementById('publicHolidaysTextSettings').value; 
            parsePublicHolidaysText(text);
            localStorage.setItem('melbournePublicHolidaysText', text); 
        }

        function updatePublicHolidaysAndRecalculate(fromSettingsPage = false) {
            updatePublicHolidays();
            showToast('Public holidays updated! Recalculating future periods...', 2500);
            recalculateFutureBidPeriods(true); 
            if (fromSettingsPage) { 
                previewSettingChanges();
            }
        }

        // --- Date Utilities (using UTC for consistency) ---
        function formatDate(dateInput) {
            if (!dateInput) return 'N/A';
            const d = (typeof dateInput === 'string') ? parseDate(dateInput) : new Date(dateInput.getTime());
            if (!d || isNaN(d.getTime())) return 'N/A';
            const day = String(d.getUTCDate()).padStart(2, '0');
            const month = String(d.getUTCMonth() + 1).padStart(2, '0');
            const year = String(d.getUTCFullYear()).slice(-2);
            const dayOfWeek = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][d.getUTCDay()];
            return `${day}/${month}/${year} (${dayOfWeek})`;
        }

        function parseDate(dateString) { // Expects YYYY-MM-DD
            if (!dateString) return null;
            const datePart = dateString.split('T')[0];
            const date = new Date(datePart + 'T00:00:00Z');
            return isNaN(date.getTime()) ? null : date;
        }
        
        function parseDisplayDate(displayDateStr) { // Expects DD/MM/YY
            if (!displayDateStr || !displayDateStr.includes('/')) return null;
            const parts = displayDateStr.split(' ')[0].split('/'); 
            if (parts.length !== 3) return null;
            const day = parseInt(parts[0], 10);
            const month = parseInt(parts[1], 10) -1; 
            const year = parseInt("20" + parts[2], 10);
            if (isNaN(day) || isNaN(month) || isNaN(year)) return null;
            return new Date(Date.UTC(year, month, day));
        }


        function formatDateForInput(dateObj) {
            if (!dateObj || isNaN(dateObj.getTime())) return '';
            const year = dateObj.getUTCFullYear();
            const month = String(dateObj.getUTCMonth() + 1).padStart(2, '0');
            const day = String(dateObj.getUTCDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function getFirstXDayOfMonth(year, month, dayOfWeek) { // month is 0-11, dayOfWeek is 0-6 (Sun-Sat)
            const date = new Date(Date.UTC(year, month, 1));
            while (date.getUTCDay() !== dayOfWeek) {
                date.setUTCDate(date.getUTCDate() + 1);
            }
            return date;
        }

        function getLastXDayOfMonth(year, month, dayOfWeek) { // month is 0-11, dayOfWeek is 0-6 (Sun-Sat)
            const date = new Date(Date.UTC(year, month + 1, 0)); // Start from last day of the given month
            while (date.getUTCDay() !== dayOfWeek) {
                date.setUTCDate(date.getUTCDate() - 1);
            }
            return date;
        }

        function isWeekend(date) { // Input is Date object
            const day = date.getUTCDay();
            return day === 6 || day === 0; // 6 for Saturday, 0 for Sunday
        }

        function isPublicHoliday(date) { // Input is Date object
            const dateString = formatDateForCalc(date); // Get YYYY-MM-DD string
            return melbournePublicHolidays.some(h => h.date === dateString);
        }
        
        function getPublicHolidayName(dateString) { // dateString is YYYY-MM-DD
            const holiday = melbournePublicHolidays.find(h => h.date === dateString);
            return holiday ? holiday.name : "Public Holiday";
        }


        function addWorkingDays(startDateStr, daysToAdd) {
            let currentDate = parseDate(startDateStr);
            if (!currentDate) return null;
            let workingDaysCounted = 0;
            while (workingDaysCounted < daysToAdd) {
                currentDate.setUTCDate(currentDate.getUTCDate() + 1); // Increment UTC date
                if (!isWeekend(currentDate) && !isPublicHoliday(currentDate)) {
                    workingDaysCounted++;
                }
            }
            return currentDate; // Return Date object
        }

        function subtractWorkingDays(startDateStr, daysToSubtract) {
            let currentDate = parseDate(startDateStr);
            if (!currentDate) return null;
            let workingDaysCounted = 0;
            while (workingDaysCounted < daysToSubtract) {
                currentDate.setUTCDate(currentDate.getUTCDate() - 1); // Decrement UTC date
                if (!isWeekend(currentDate) && !isPublicHoliday(currentDate)) {
                    workingDaysCounted++;
                }
            }
            return currentDate; // Return Date object
        }

        function addCalendarDays(startDateStr, daysToAdd) { // Helper to add calendar days
            let currentDate = parseDate(startDateStr);
            if (!currentDate) return null;
            currentDate.setUTCDate(currentDate.getUTCDate() + daysToAdd);
            return currentDate;
        }


        function getFinalAdjustedDate(baseDateStr) {
            let currentDate = parseDate(baseDateStr);
            if (!currentDate) return null;
            while (isWeekend(currentDate) || isPublicHoliday(currentDate)) {
                currentDate.setUTCDate(currentDate.getUTCDate() - 1); // Decrement UTC date
            }
            return currentDate; // Return Date object
        }

        function getEOMPriorRoster(rosterStartDateStr) {
            const rosterStartDate = parseDate(rosterStartDateStr);
            if (!rosterStartDate) return null;
            const firstDayOfRosterMonth = new Date(Date.UTC(rosterStartDate.getUTCFullYear(), rosterStartDate.getUTCMonth(), 1));
            const eomPrior = new Date(firstDayOfRosterMonth);
            eomPrior.setUTCDate(eomPrior.getUTCDate() - 1);
            return eomPrior; // Return Date object
        }

        function formatDateForCalc(dateObj) { // Convert Date object to YYYY-MM-DD
            if (!dateObj || isNaN(dateObj.getTime())) return null;
            return `${dateObj.getUTCFullYear()}-${String(dateObj.getUTCMonth() + 1).padStart(2, '0')}-${String(dateObj.getUTCDate()).padStart(2, '0')}`;
        }

        // --- Roster Date Pre-population ---
        function getStandardRosterDates(bidMonthName, bidYear) { // bidMonthName is 3-letter like "Jan"
            const monthIdx = monthMap[bidMonthName]; 
            if (monthIdx === undefined) {
                console.error("Invalid bidMonthName passed to getStandardRosterDates:", bidMonthName);
                return null;
            }
            
            const definition = standardRosterPeriodDefinitions.find(def => def.period.toLowerCase() === bidMonthName.toLowerCase());
            if (!definition) {
                 console.error("No roster definition found for:", bidMonthName);
                 return null;
            }

            return { 
                startDateStr: definition.startRule(bidYear), 
                endDateStr: definition.endRule(bidYear) 
            };
        }

        function populateYearDropdown() {
            const yearSelect = document.getElementById('selectBidYear');
            const sampleYearSelect = document.getElementById('samplePreviewYear');
            const currentYear = new Date().getFullYear();
            
            [yearSelect, sampleYearSelect].forEach(selectEl => {
                if (!selectEl) return;
                selectEl.innerHTML = ''; 
                for (let i = currentYear - 2; i <= currentYear + 5; i++) { 
                    const option = document.createElement('option');
                    option.value = i;
                    option.textContent = i;
                    selectEl.appendChild(option);
                }
                selectEl.value = currentYear; 
            });
            
            yearSelect.addEventListener('change', () => {
                populateBidMonthDropdown(parseInt(yearSelect.value));
                suggestSpCutoffDate(false); // Pass false for user interaction
            });
        }

        function populateBidMonthDropdown(selectedYear) {
            const monthSelect = document.getElementById('selectBidMonth');
            const sampleMonthSelect = document.getElementById('samplePreviewMonth');
            const currentMonthValue = monthSelect.value; 
            
            [monthSelect, sampleMonthSelect].forEach(selectEl => {
                if (!selectEl) return;
                selectEl.innerHTML = ''; 
                // Add safety checks for entries without bidPeriodName
                const existingBidNamesForYear = allBidPeriodData
                    .filter(p => {
                        if (!p || typeof p.bidPeriodName !== 'string') {
                            console.error('Invalid bid period entry:', p);
                            return false;
                        }
                        try {
                            const parts = p.bidPeriodName.match(/^([a-zA-Z]{3})-?(\d{2}|\d{4})$/);
                            if (parts) {
                                let yearPart = parts[2];
                                let year = (yearPart.length === 2) ? parseInt("20" + yearPart) : parseInt(yearPart);
                                return year === selectedYear;
                            }
                        } catch (err) {
                            console.error('Error processing bid period for dropdown:', err);
                        }
                        return false;
                    })
                    .map(p => p.bidPeriodName.substring(0,3).toLowerCase());

                Object.keys(monthMap).forEach(monthKey => {
                    if (selectEl.id === 'selectBidMonth' && existingBidNamesForYear.includes(monthKey.toLowerCase())) {
                        return; 
                    }
                    const option = document.createElement('option');
                    option.value = monthKey; 
                    option.textContent = monthKey;
                    selectEl.appendChild(option);
                });

                if (selectEl.id === 'selectBidMonth') {
                    if (Array.from(selectEl.options).some(opt => opt.value === currentMonthValue)) {
                        selectEl.value = currentMonthValue;
                    } else if (selectEl.options.length > 0 && !selectEl.options[0].disabled) {
                         selectEl.selectedIndex = 0;
                    }
                } else if (selectEl.id === 'samplePreviewMonth' && selectEl.options.length > 0) {
                     selectEl.selectedIndex = 0; 
                }


                if (selectEl.options.length === 0) {
                    const option = document.createElement('option');
                    option.textContent = selectEl.id === 'selectBidMonth' ? "No available months" : "Months";
                    option.disabled = true;
                    selectEl.appendChild(option);
                }
            });
            monthSelect.addEventListener('change', () => suggestSpCutoffDate(false)); // Pass false for user interaction
       }
       
        
        function suggestSpCutoffDate(isInitializing = false) { // Added isInitializing parameter
            console.log(`DEBUG: suggestSpCutoffDate called. isInitializing: ${isInitializing}, Selected Year: ${document.getElementById('selectBidYear').value}, Selected Month: ${document.getElementById('selectBidMonth').value}`);
            const selectedYear = parseInt(document.getElementById('selectBidYear').value);
            const selectedMonthKey = document.getElementById('selectBidMonth').value;
            const spCutoffDateInput = document.getElementById('spCutoffDate');

            if (!selectedMonthKey || !selectedYear || document.getElementById('selectBidMonth').options[0]?.disabled) {
                spCutoffDateInput.value = ''; 
                return;
            }

            const standardRosterDates = getStandardRosterDates(selectedMonthKey, selectedYear);
            if (!standardRosterDates || !standardRosterDates.startDateStr) {
                spCutoffDateInput.value = ''; return;
            }

            const rosterStartDateForSP = parseDate(standardRosterDates.startDateStr);
            if (!rosterStartDateForSP) {
                spCutoffDateInput.value = ''; return;
            }
            
            let spCutoffSuggestion;
            if (selectedMonthKey === 'Feb') { // Special rule for Feb SP Cutoff suggestion
                 spCutoffSuggestion = new Date(Date.UTC(rosterStartDateForSP.getUTCFullYear(), monthMap['Dec'] -12 , appSettings.spCutoffRule.day)); // December of previous year
            } else {
                 spCutoffSuggestion = new Date(Date.UTC(rosterStartDateForSP.getUTCFullYear(), rosterStartDateForSP.getUTCMonth() - appSettings.spCutoffRule.monthsPrior, appSettings.spCutoffRule.day));
            }
            
            if (appSettings.spCutoffRule.weekendAdjustment === 'nextWorkingDay') {
                let dayOfWeek = spCutoffSuggestion.getUTCDay();
                if (dayOfWeek === SATURDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 2); }
                else if (dayOfWeek === SUNDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 1); }
                while(isPublicHoliday(spCutoffSuggestion)){ 
                     spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 1);
                     dayOfWeek = spCutoffSuggestion.getUTCDay();
                     if (dayOfWeek === SATURDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 2); }
                     else if (dayOfWeek === SUNDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 1); }
                }
            } else if (appSettings.spCutoffRule.weekendAdjustment === 'previousWorkingDay') {
                spCutoffSuggestion = getFinalAdjustedDate(formatDateForInput(spCutoffSuggestion));
            }

            spCutoffDateInput.value = formatDateForInput(spCutoffSuggestion);

            // Validate dates before proceeding
            if (!selectedMonthKey || !standardRosterDates.startDateStr || !standardRosterDates.endDateStr || !spCutoffDateInput.value) {
                showToast('Error: Missing required dates for auto-add. Check console for details.', 4000);
                console.error('Missing required dates for auto-add', {
                    bidPeriodName: `${selectedMonthKey}-${String(selectedYear).slice(-2)}`,
                    rosterStartDate: standardRosterDates.startDateStr,
                    rosterEndDate: standardRosterDates.endDateStr,
                    spCutoffDate: spCutoffDateInput.value
                });
                return;
            }

            // The primary role of suggestSpCutoffDate is to update the input field.
            // Automatic adding should be handled by explicit user actions or specific initialization logic.
            // We keep the console.log for the suggestion itself for debugging.
            console.log('DEBUG: suggestSpCutoffDate - Suggested SP Cutoff for input field:', {
                bidPeriodName: `${selectedMonthKey}-${String(selectedYear).slice(-2)}`,
                rosterStartDate: standardRosterDates.startDateStr,
                rosterEndDate: standardRosterDates.endDateStr,
                spCutoffDate: spCutoffDateInput.value // Log the value that was set in the input
            });

            if (!isInitializing) {
                // If not initializing, it means a user changed the dropdown.
                // We don't auto-add here anymore. User must click a button.
                console.log('DEBUG: suggestSpCutoffDate - User changed dropdown. SP Cutoff date suggested in input. No auto-add.');
            } else {
                // During initialization, we also just suggest, no auto-add.
                console.log('DEBUG: suggestSpCutoffDate - Initializing. SP Cutoff date suggested in input. No auto-add.');
            }
        }


        // --- Main Application Logic: Adding a Bid Period ---
function autoAddAndCalculateNextBidPeriod() {
            console.log('DEBUG: autoAddAndCalculateNextBidPeriod - START. Current allBidPeriodData:', JSON.parse(JSON.stringify(allBidPeriodData)));
            let nextYear, nextMonthKey;
            const spCutoffDateInput = document.getElementById('spCutoffDate');

            if (allBidPeriodData.length === 0) {
                // If no periods exist, use the current dropdown selection
                nextYear = parseInt(document.getElementById('selectBidYear').value);
                nextMonthKey = document.getElementById('selectBidMonth').value;
                if (!nextMonthKey || document.getElementById('selectBidMonth').options[0]?.disabled) {
                    showToast("Please select an available Bid Month to start.", 3000);
                    return;
                }
            } else {
                // Find the latest period to determine the next one
                console.log("DEBUG: autoAddAndCalculateNextBidPeriod - Finding latest period from:", JSON.parse(JSON.stringify(allBidPeriodData)));
                const latestPeriod = allBidPeriodData.reduce((latest, current) => {
                    console.log(`DEBUG: latestPeriod reduce - latest: ${latest.bidPeriodName} (${latest.rosterStart?.getTime()}), current: ${current.bidPeriodName} (${current.rosterStart?.getTime()})`);
                    if (!latest.rosterStart || !(latest.rosterStart instanceof Date)) { console.warn("Latest has invalid rosterStart", latest); return current; }
                    if (!current.rosterStart || !(current.rosterStart instanceof Date)) { console.warn("Current has invalid rosterStart", current); return latest; }
                    return (latest.rosterStart.getTime() > current.rosterStart.getTime()) ? latest : current;
                });
                console.log("DEBUG: autoAddAndCalculateNextBidPeriod - Determined latestPeriod:", JSON.parse(JSON.stringify(latestPeriod)));

                // --- MODIFIED LOGIC TO DETERMINE NEXT PERIOD ---
                const lastBidName = latestPeriod.bidPeriodName; // e.g., "Feb-26"
                const nameParts = lastBidName.match(/^([a-zA-Z]{3})-?(\d{2}|\d{4})$/);
                if (!nameParts || nameParts.length < 3) {
                    showToast(`Error: Could not parse bid name: ${lastBidName}`, 4000);
                    console.error("autoAddAndCalculateNextBidPeriod: Could not parse latestPeriod.bidPeriodName", lastBidName);
                    return;
                }
                const lastMonthKey = nameParts[1]; // "Feb"
                const lastYearStr = nameParts[2]; // "26"
                const lastYear = parseInt(lastYearStr.length === 2 ? "20" + lastYearStr : lastYearStr); // 2026

                let currentPeriodMonthIndex = monthMap[lastMonthKey]; // monthMap["Feb"] = 1

                if (typeof currentPeriodMonthIndex === 'undefined') {
                    showToast(`Error: Invalid month key from bid name: ${lastMonthKey}`, 4000);
                    console.error("autoAddAndCalculateNextBidPeriod: Invalid month key from latestPeriod.bidPeriodName", lastMonthKey);
                    return;
                }

                // Determine next month and year
                nextPeriodMonthIndex = (currentPeriodMonthIndex + 1) % 12;
                nextYear = lastYear + Math.floor((currentPeriodMonthIndex + 1) / 12);
                nextMonthKey = Object.keys(monthMap).find(key => monthMap[key] === nextPeriodMonthIndex);
                console.log(`DEBUG: autoAddAndCalculateNextBidPeriod - Calculated next: MonthKey=${nextMonthKey}, Year=${nextYear} from latest: ${lastBidName}`);
            }

            if (!nextMonthKey) {
                showToast("Error: Could not determine the next bid period.", 3000);
                console.error("autoAddAndCalculateNextBidPeriod: Could not determine nextMonthKey.");
                return;
            }
            
            const bidPeriodName = `${nextMonthKey}-${String(nextYear).slice(-2)}`;

            // Check if this period already exists (e.g., if dropdowns were manually changed after auto-add)
            if (allBidPeriodData.some(p => p.bidPeriodName === bidPeriodName)) {
                showToast(`Bid period ${bidPeriodName} already exists.`, 3000);
                // Optionally, advance to the *next* available month in dropdown
                populateBidMonthDropdown(nextYear); 
                const monthSelect = document.getElementById('selectBidMonth');
                if (monthSelect.options.length > 0 && !monthSelect.options[0].disabled) {
                     suggestSpCutoffDate(false); // Suggest for the new selection
                }
                return;
            }

            const standardRosterDates = getStandardRosterDates(nextMonthKey, nextYear);
            if (!standardRosterDates || !standardRosterDates.startDateStr) {
                showToast(`Error: Could not determine roster dates for ${bidPeriodName}.`, 4000);
                return;
            }

            const rosterStartDateForSP = parseDate(standardRosterDates.startDateStr);
            if (!rosterStartDateForSP) {
                showToast(`Error: Could not parse roster start date for ${bidPeriodName}.`, 4000);
                return;
            }

            let spCutoffSuggestion;
            // Use appSettings for SP Cutoff calculation
            if (nextMonthKey === 'Feb') { // Special rule for Feb SP Cutoff suggestion
                 spCutoffSuggestion = new Date(Date.UTC(rosterStartDateForSP.getUTCFullYear(), monthMap['Dec'] -12 , appSettings.spCutoffRule.day));
            } else {
                 spCutoffSuggestion = new Date(Date.UTC(rosterStartDateForSP.getUTCFullYear(), rosterStartDateForSP.getUTCMonth() - appSettings.spCutoffRule.monthsPrior, appSettings.spCutoffRule.day));
            }
            
            if (appSettings.spCutoffRule.weekendAdjustment === 'nextWorkingDay') {
                let dayOfWeek = spCutoffSuggestion.getUTCDay();
                if (dayOfWeek === SATURDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 2); }
                else if (dayOfWeek === SUNDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 1); }
                while(isPublicHoliday(spCutoffSuggestion)){ 
                     spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 1);
                     dayOfWeek = spCutoffSuggestion.getUTCDay();
                     if (dayOfWeek === SATURDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 2); }
                     else if (dayOfWeek === SUNDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 1); }
                }
            } else if (appSettings.spCutoffRule.weekendAdjustment === 'previousWorkingDay') {
                spCutoffSuggestion = getFinalAdjustedDate(formatDateForInput(spCutoffSuggestion));
            }
            const calculatedSpCutoffDateStr = formatDateForInput(spCutoffSuggestion);

            console.log('DEBUG: autoAddAndCalculateNextBidPeriod - About to call addBidPeriod. Period to add:', {
                bidPeriodName: bidPeriodName,
                rosterStartDate: standardRosterDates.startDateStr,
                rosterEndDate: standardRosterDates.endDateStr,
                spCutoffDate: calculatedSpCutoffDateStr
            });

            addBidPeriod({
                bidPeriodName: bidPeriodName,
                rosterStartDate: standardRosterDates.startDateStr,
                rosterEndDate: standardRosterDates.endDateStr,
                spCutoffDate: calculatedSpCutoffDateStr
            }, false); // false because this is a user action

            showToast(`Auto-added and calculated: ${bidPeriodName}`, 3000);
            
            // Update dropdowns to reflect the next available period
            const newNextYear = (nextMonthKey === 'Dec') ? nextYear + 1 : nextYear;
            const newNextMonthIndex = (monthMap[nextMonthKey] + 1) % 12;
            
            document.getElementById('selectBidYear').value = newNextYear;
            populateBidMonthDropdown(newNextYear);
            const monthSelect = document.getElementById('selectBidMonth');
            
            // Try to select the month after the one just added
            const monthAfterAddedKey = Object.keys(monthMap).find(key => monthMap[key] === newNextMonthIndex);
            if (monthAfterAddedKey && Array.from(monthSelect.options).some(opt => opt.value === monthAfterAddedKey && !opt.disabled)) {
                monthSelect.value = monthAfterAddedKey;
            } else if (monthSelect.options.length > 0 && !monthSelect.options[0].disabled) {
                // Fallback to the first available option if the ideal next is not available (e.g., already added)
                monthSelect.selectedIndex = 0;
            }
            suggestSpCutoffDate(false); // Update suggested SP cutoff for the new selection
        }
        function addBidPeriodFromForm() { 
            const selectedYear = parseInt(document.getElementById('selectBidYear').value);
            const selectedMonthKey = document.getElementById('selectBidMonth').value;
            const spCutoffDateStr = document.getElementById('spCutoffDate').value;

            if (!selectedMonthKey || document.getElementById('selectBidMonth').options[0]?.disabled) {
                 showToast("Please select an available Bid Month.", 3000); return;
            }
            if (!spCutoffDateStr) {
                 showToast("SP Cutoff Date is required for manual addition.", 3000); return;
            }

            const bidPeriodName = `${selectedMonthKey}-${String(selectedYear).slice(-2)}`;
            const standardRosterDates = getStandardRosterDates(selectedMonthKey, selectedYear);

            if (!standardRosterDates) {
                showToast(`Error: Could not determine roster dates for ${bidPeriodName}.`, 4000); return;
            }
            
            addBidPeriod({
                bidPeriodName: bidPeriodName,
                rosterStartDate: standardRosterDates.startDateStr,
                rosterEndDate: standardRosterDates.endDateStr,
                spCutoffDate: spCutoffDateStr
            }, false); 
        }


        function addBidPeriod(periodData, isInitialLoadOrRecalc = false, existingId = null) {
            console.log('DEBUG: addBidPeriod - START. isInitialLoadOrRecalc:', isInitialLoadOrRecalc, 'existingId:', existingId);
            console.log('DEBUG: addBidPeriod - periodData received:', JSON.parse(JSON.stringify(periodData)));
            console.log('DEBUG: addBidPeriod - allBidPeriodData BEFORE modification:', JSON.parse(JSON.stringify(allBidPeriodData)));
            // Log input data for debugging
            console.log('addBidPeriod called with:', JSON.stringify(periodData));
            let { bidPeriodName, rosterStartDate: rosterStartDateStr, rosterEndDate: rosterEndDateStr, spCutoffDate: spCutoffDateStr } = periodData;

            try {
                if (!bidPeriodName || !rosterStartDateStr || !rosterEndDateStr || !spCutoffDateStr) {
                    console.error('Missing required data in addBidPeriod:', { bidPeriodName, rosterStartDateStr, rosterEndDateStr, spCutoffDateStr });
                    throw new Error("Internal Error: Incomplete period data provided to addBidPeriod.");
                }

                const startDate = parseDate(rosterStartDateStr); const endDate = parseDate(rosterEndDateStr); const cutoffDate = parseDate(spCutoffDateStr);
                if (!startDate || !endDate || !cutoffDate) { throw new Error("Invalid date format in period data."); }
                if (endDate <= startDate) { throw new Error('Roster End Date must be after Roster Start Date in period data.'); }
                if (cutoffDate >= startDate) { throw new Error('SP Cutoff Date must be before Roster Start Date in period data.'); }

                const spFeedbackDate = addWorkingDays(spCutoffDateStr, appSettings.spFeedbackOffset);
                const tradeOffDiscussionDate = addWorkingDays(formatDateForCalc(spFeedbackDate), appSettings.tradeOffOffset);
                let finalSSIMHandoverDate = addWorkingDays(formatDateForCalc(tradeOffDiscussionDate), appSettings.ssimHandoverOffset);
                
                if (appSettings.ssimFridayRule && finalSSIMHandoverDate.getUTCDay() === FRIDAY) {
                    let prevDay = new Date(finalSSIMHandoverDate.getTime());
                    prevDay.setUTCDate(prevDay.getUTCDate() - 1); 
                    finalSSIMHandoverDate = getFinalAdjustedDate(formatDateForCalc(prevDay)); 
                }


                // const eomPriorRoster = getEOMPriorRoster(rosterStartDateStr); // No longer using EOM-Prior for publish dates
                // if (!eomPriorRoster) { throw new Error("Could not determine EOM Prior Roster from period data."); }
                
                // Publish dates are now calculated X clear days before Roster Start Date itself
                const baseTechCrewPublishDate = new Date(startDate.getTime()); // Use startDate (parsed rosterStartDateStr)
                baseTechCrewPublishDate.setUTCDate(baseTechCrewPublishDate.getUTCDate() - (appSettings.techCrewPublishOffset + 1)); // Using (offset + 1) for clear days
                const finalTechCrewPublishDate = getFinalAdjustedDate(formatDateForCalc(baseTechCrewPublishDate)); // Adjustment remains
                
                const baseCabinCrewPublishDate = new Date(startDate.getTime()); // Use startDate
                baseCabinCrewPublishDate.setUTCDate(baseCabinCrewPublishDate.getUTCDate() - (appSettings.cabinCrewPublishOffset + 1)); // Using (offset + 1) for clear days
                const finalCabinCrewPublishDate = getFinalAdjustedDate(formatDateForCalc(baseCabinCrewPublishDate)); // Adjustment remains

                const periodEventDates = [cutoffDate, spFeedbackDate, tradeOffDiscussionDate, finalSSIMHandoverDate, finalTechCrewPublishDate, finalCabinCrewPublishDate].filter(Boolean);
                const earliestEvent = new Date(Math.min(...periodEventDates.map(d => d.getTime())));
                const latestEvent = new Date(Math.max(...periodEventDates.map(d => d.getTime())));
                const affectedHolidaysList = [];
                if (earliestEvent && latestEvent && !isNaN(earliestEvent.getTime()) && !isNaN(latestEvent.getTime())) {
                    for (let d = new Date(earliestEvent); d <= latestEvent; d.setUTCDate(d.getUTCDate() + 1)) {
                        const dStr = formatDateForCalc(new Date(d));
                        if (melbournePublicHolidays.some(h => h.date === dStr)) {
                            affectedHolidaysList.push({date: dStr, name: getPublicHolidayName(dStr)});
                        }
                    }
                }

                const newEntry = {
                    id: existingId || Date.now() + bidPeriodName.replace(/\s/g, '_'), bidPeriodName,
                    rosterStart: startDate, rosterEnd: endDate, spCutoff: cutoffDate, spFeedback: spFeedbackDate,
                    tradeOffDiscussion: tradeOffDiscussionDate, finalSSIMHandover: finalSSIMHandoverDate,
                    techCrewPublish: finalTechCrewPublishDate, cabinCrewPublish: finalCabinCrewPublishDate,
                    affectedHolidays: affectedHolidaysList 
                };
                
                const existingIndex = allBidPeriodData.findIndex(p => p.id === newEntry.id);
                if (existingIndex > -1) {
                    console.log('DEBUG: addBidPeriod - Updating existing period at index:', existingIndex);
                    allBidPeriodData[existingIndex] = newEntry;
                } else {
                    console.log('DEBUG: addBidPeriod - Pushing new period.');
                    allBidPeriodData.push(newEntry);
                }
                console.log('DEBUG: addBidPeriod - allBidPeriodData AFTER modification (before sort/filter):', JSON.parse(JSON.stringify(allBidPeriodData)));
                // Normalize property names and ensure rosterStart is a valid Date for sorting
                console.log('ADD_BID_PERIOD: Normalizing and filtering allBidPeriodData before sort. Current size:', allBidPeriodData.length);
                allBidPeriodData = allBidPeriodData.map(period => {
                    const normalizedPeriod = { ...period }; // Shallow copy

                    // Normalize startDate/endDate to rosterStart/rosterEnd
                    if (normalizedPeriod.startDate && typeof normalizedPeriod.rosterStart === 'undefined') {
                        normalizedPeriod.rosterStart = normalizedPeriod.startDate;
                        delete normalizedPeriod.startDate; // Clean up old property
                    }
                    if (normalizedPeriod.endDate && typeof normalizedPeriod.rosterEnd === 'undefined') {
                        normalizedPeriod.rosterEnd = normalizedPeriod.endDate;
                        delete normalizedPeriod.endDate; // Clean up old property
                    }

                    // Ensure rosterStart is a Date object
                    if (normalizedPeriod.rosterStart && !(normalizedPeriod.rosterStart instanceof Date)) {
                        const parsedDate = new Date(normalizedPeriod.rosterStart);
                        if (parsedDate instanceof Date && !isNaN(parsedDate.getTime())) {
                            normalizedPeriod.rosterStart = parsedDate;
                        } else {
                            console.warn(`ADD_BID_PERIOD: Invalid date string for rosterStart: '${normalizedPeriod.rosterStart}' in period ID '${normalizedPeriod.id}'. Marking for filtering.`);
                            normalizedPeriod.rosterStart = null; // Mark as invalid
                        }
                    }
                    
                    // Ensure rosterEnd is a Date object (though not used in this sort, good for consistency)
                    if (normalizedPeriod.rosterEnd && !(normalizedPeriod.rosterEnd instanceof Date)) {
                        const parsedEndDate = new Date(normalizedPeriod.rosterEnd);
                        if (parsedEndDate instanceof Date && !isNaN(parsedEndDate.getTime())) {
                            normalizedPeriod.rosterEnd = parsedEndDate;
                        } else {
                            console.warn(`ADD_BID_PERIOD: Invalid date string for rosterEnd: '${normalizedPeriod.rosterEnd}' in period ID '${normalizedPeriod.id}'. Setting to null.`);
                            normalizedPeriod.rosterEnd = null; 
                        }
                    }
                    return normalizedPeriod;
                }).filter(period => {
                    const isValidForSort = period.rosterStart instanceof Date && !isNaN(period.rosterStart.getTime());
                    const hasBidPeriodName = typeof period.bidPeriodName === 'string' && period.bidPeriodName.trim() !== '';

                    if (!isValidForSort) {
                        console.warn(`ADD_BID_PERIOD: Filtering out period ID '${period.id || 'N/A'}' due to missing or invalid rosterStart. Period data:`, JSON.parse(JSON.stringify(period)));
                    }
                    // Log missing bidPeriodName only if rosterStart was valid, to avoid redundant logs for the same item
                    if (!hasBidPeriodName && isValidForSort) { 
                        console.warn(`ADD_BID_PERIOD: Filtering out period ID '${period.id || 'N/A'}' due to missing or invalid bidPeriodName. Period data:`, JSON.parse(JSON.stringify(period)));
                    }
                    return isValidForSort && hasBidPeriodName;
                });
                console.log('ADD_BID_PERIOD: Normalization and filtering complete. New size:', allBidPeriodData.length);

                // Use a safer sort with try/catch
                try {
                    allBidPeriodData.sort((a, b) => a.rosterStart.getTime() - b.rosterStart.getTime());
                } catch (err) {
                    console.error('Sort error in addBidPeriod:', err);
                }

                console.log('ADD_BID_PERIOD: About to render. allBidPeriodData:', JSON.parse(JSON.stringify(allBidPeriodData)));
                renderResultsTable(); renderCalendarView(); updateEmptyStateMessages();
                populateBidMonthDropdown(parseInt(document.getElementById('selectBidYear').value)); 

                if (!isInitialLoadOrRecalc && !existingId) { 
                    document.getElementById('spCutoffDate').value = '';
                    suggestSpCutoffDate(false); // Pass false, as this is part of an explicit add flow
                    showToast(`Bid period ${bidPeriodName} added successfully!`, 2000);
                }
                saveBidPeriodData(); // Save after any modification
            } catch (error) {
                 showToast(`Error processing bid period ${bidPeriodName}: ${error.message}`, 4000);
                 console.error("Error in addBidPeriod core:", error, periodData);
            }
        }


        function renderResultsTable() {
            console.log('RENDER_RESULTS_TABLE: Starting execution');
            const tableBody = document.getElementById('resultsBody');
            tableBody.innerHTML = '';

            if (allBidPeriodData.length === 0) {
                 updateEmptyStateMessages();
                 updateSsimTableNavDisplay(); // Update nav display even if empty
                 return;
            }

            // Filter data based on ssimTableViewStartDate and ssimTableMonthsToDisplay
            const viewEndDate = new Date(ssimTableViewStartDate.getTime());
            viewEndDate.setUTCMonth(viewEndDate.getUTCMonth() + ssimTableMonthsToDisplay);
            viewEndDate.setUTCDate(0); // Go to the last day of the target month

            console.log(`DEBUG: renderResultsTable - Filtering data from ${ssimTableViewStartDate.toISOString()} to ${viewEndDate.toISOString()}`);

            const viewableBidPeriods = allBidPeriodData.filter(period => {
                // Ensure rosterStart is a valid Date object before comparison
                if (!period.rosterStart || !(period.rosterStart instanceof Date) || isNaN(period.rosterStart.getTime())) {
                    console.warn("RENDER_RESULTS_TABLE: Skipping period with invalid rosterStart:", JSON.parse(JSON.stringify(period)));
                    return false;
                }
                // Include periods whose roster start date falls within the view window
                return period.rosterStart.getTime() >= ssimTableViewStartDate.getTime() &&
                       period.rosterStart.getTime() <= viewEndDate.getTime();
            });

            console.log(`DEBUG: renderResultsTable - Found ${viewableBidPeriods.length} viewable periods.`);

            viewableBidPeriods.forEach(period => {
                const newRow = tableBody.insertRow();

                // Add modified row indicator if dates were manually adjusted
                if (period.datesManuallyModified) {
                    newRow.classList.add('modified-row');
                    newRow.title = `Dates manually adjusted${period.lastModifiedDate ? ' on ' + new Date(period.lastModifiedDate).toLocaleDateString() : ''}`;
                }

                const bidPeriodCell = newRow.insertCell();
                bidPeriodCell.textContent = period.bidPeriodName;

                // Add modified indicator dot after bid period name
                if (period.datesManuallyModified) {
                    const modifiedIndicator = document.createElement('span');
                    modifiedIndicator.className = 'date-modified-indicator';
                    modifiedIndicator.title = 'Dates manually adjusted';
                    bidPeriodCell.appendChild(modifiedIndicator);
                }

                if (period.affectedHolidays && period.affectedHolidays.length > 0) {
                    const infoIcon = document.createElement('span');
                    infoIcon.className = 'info-icon';
                    infoIcon.innerHTML = '&#9432;';
                    infoIcon.addEventListener('mouseover', (event) => showHolidayTooltip(event, period.affectedHolidays));
                    infoIcon.addEventListener('mouseout', hideHolidayTooltip);
                    bidPeriodCell.appendChild(infoIcon);
                }

                const cell = newRow.insertCell();
                cell.setAttribute('data-type', 'planning');
                cell.setAttribute('data-date', period.spCutoff.toISOString());
                cell.textContent = formatDate(period.spCutoff);

                const cell2 = newRow.insertCell();
                cell2.setAttribute('data-type', 'planning');
                cell2.setAttribute('data-date', period.spFeedback.toISOString());
                cell2.textContent = formatDate(period.spFeedback);

                newRow.insertCell().textContent = formatDate(period.tradeOffDiscussion);
                newRow.insertCell().textContent = formatDate(period.finalSSIMHandover);
                newRow.insertCell().textContent = formatDate(period.techCrewPublish);
                newRow.insertCell().textContent = formatDate(period.cabinCrewPublish);

                const statusCell = newRow.insertCell();
                const statusPill = document.createElement('span');
                statusPill.textContent = period.approvalStatus || 'Pending'; // Ensure text content is set
                statusPill.className = 'px-3 py-1 rounded-full text-xs font-semibold leading-tight '; // Added leading-tight for better vertical alignment
                if (period.approvalStatus === 'Approved') {
                    statusPill.classList.add('bg-green-100', 'text-green-700');
                } else { // Pending or undefined
                    statusPill.classList.add('bg-yellow-100', 'text-yellow-700');
                }
                statusCell.appendChild(statusPill);

                const actionsCell = newRow.insertCell();
                actionsCell.className = 'px-4 py-3 text-sm';
                const editButton = document.createElement('button');
                editButton.textContent = 'Edit';
                editButton.className = 'bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-1 px-3 rounded-md text-xs';
                editButton.onclick = () => openEditModal(period.id);
                actionsCell.appendChild(editButton);

                Array.from(newRow.cells).forEach((cell, index) => {
                    if (index < newRow.cells.length -1) {
                         cell.className = 'px-4 py-3 whitespace-nowrap text-sm text-gray-700';
                    }
                });
            });

            updateEmptyStateMessages(); // Update empty message based on *all* data
            updateSsimTableNavDisplay(); // Update navigation display and button states
        }

        // --- Calendar View Logic ---
        function extendCalendar() {
            calendarMonthsToDisplay += 6;
            renderCalendarView();
            showToast(`Calendar extended to ${calendarMonthsToDisplay} months.`, 2000);
        }

        function renderCalendarView() {
            console.log('RENDER_CALENDAR_VIEW: Starting execution');
            const calendarGridContainer = document.getElementById('calendarGridContainer');
            calendarGridContainer.innerHTML = ''; // Clear previous grid content

            const today = new Date();
            today.setUTCHours(0, 0, 0, 0); // Normalize today to midnight for accurate date comparison
            const todayUTC = new Date(Date.UTC(today.getFullYear(), today.getMonth(), today.getDate()));


            // Add Header Row for Days 1-31
            const headerPlaceholder = document.createElement('div');
            headerPlaceholder.className = 'calendar-grid-header calendar-month-header-placeholder'; // Combined classes
            headerPlaceholder.setAttribute('role', 'columnheader'); // For accessibility
            calendarGridContainer.appendChild(headerPlaceholder);

            for (let i = 1; i <= 31; i++) {
                const dayHeader = document.createElement('div');
                dayHeader.className = 'calendar-grid-header'; // Use common header style
                dayHeader.textContent = i;
                dayHeader.setAttribute('role', 'columnheader');
                calendarGridContainer.appendChild(dayHeader);
            }


            // if (allBidPeriodData.length === 0) { updateEmptyStateMessages(); return; } // Keep this, but the calendar should render regardless of data for the time slots

            // Phase 1 Change: Set calendar start based on current real-world date - 1 month
            // Phase 2 Change: Use calendarViewStartDate
            if (!calendarViewStartDate) { // Should be initialized by initialize()
                console.error("calendarViewStartDate is not initialized!");
                // Fallback to current month -1 if not initialized (should not happen)
                const today = new Date();
                calendarViewStartDate = new Date(Date.UTC(today.getFullYear(), today.getMonth() - 1, 1));
            }

            // Determine starting roster period based on calendarViewStartDate
            let currentRosterYear = calendarViewStartDate.getUTCFullYear();
            let currentRosterMonthIndex = calendarViewStartDate.getUTCMonth(); // Standard month index

            // Find the initial roster period definition.
            // This simple approach takes the definition for the month of calendarViewStartDate.
            // A more complex approach might find the roster period *containing* calendarViewStartDate.
            let currentRosterDefIndex = standardRosterPeriodDefinitions.findIndex(def => def.period.toLowerCase() === monthNames[currentRosterMonthIndex].substring(0,3).toLowerCase());
            if (currentRosterDefIndex === -1) currentRosterDefIndex = 0; // Fallback

            console.log(`DEBUG: renderCalendarView - Initial Roster: Year=${currentRosterYear}, DefIndex=${currentRosterDefIndex} (${standardRosterPeriodDefinitions[currentRosterDefIndex].period})`);

            for (let i = 0; i < calendarMonthsToDisplay; i++) { // Display 6 roster periods
                const rosterPeriodDef = standardRosterPeriodDefinitions[currentRosterDefIndex];
                const rosterName = `${rosterPeriodDef.period}-${String(currentRosterYear).slice(-2)}`;
                
                // These will be used by day cell logic later
                const actualRosterStartDate = parseDate(rosterPeriodDef.startRule(currentRosterYear));
                const actualRosterEndDate = parseDate(rosterPeriodDef.endRule(currentRosterYear));
                
                // console.log(`DEBUG: Rendering Roster Row for ${rosterName}, Start: ${actualRosterStartDate}, End: ${actualRosterEndDate}`);

                // Add Roster Period Name Cell for this row
                const rosterNameCell = document.createElement('div');
                rosterNameCell.className = 'calendar-grid-month-name'; // Reuse class for now
                rosterNameCell.textContent = rosterName;
                rosterNameCell.setAttribute('role', 'rowheader');
                calendarGridContainer.appendChild(rosterNameCell);

                // New day cell rendering logic based on roster period's actual dates
                for (let dayColumnIndex = 0; dayColumnIndex < 31; dayColumnIndex++) { // 0 to 30 for 31 columns
                    const dayCell = document.createElement('div');
                    dayCell.className = 'calendar-grid-day-cell';
                    dayCell.setAttribute('role', 'gridcell');

                    // Calculate the actual date this cell represents for the current roster period
                    let actualCellDate = new Date(actualRosterStartDate.getTime());
                    actualCellDate.setUTCDate(actualRosterStartDate.getUTCDate() + dayColumnIndex);

                    if (actualRosterStartDate && actualRosterEndDate && /* Ensure valid start/end from rosterPeriodDef */
                        actualCellDate.getTime() >= actualRosterStartDate.getTime() &&
                        actualCellDate.getTime() <= actualRosterEndDate.getTime()) {
                        
                        const dayNumberWrapper = document.createElement('div');
                        dayNumberWrapper.className = 'day-number-wrapper';
                        dayNumberWrapper.textContent = actualCellDate.getUTCDate(); // Show day of the month
                        dayCell.appendChild(dayNumberWrapper);

                        if (isWeekend(actualCellDate)) { dayCell.classList.add('weekend'); }

                        // Add classes for past and current dates
                        const normalizedActualCellDate = new Date(Date.UTC(actualCellDate.getUTCFullYear(), actualCellDate.getUTCMonth(), actualCellDate.getUTCDate()));
                        
                        if (normalizedActualCellDate.getTime() < todayUTC.getTime()) {
                            dayCell.classList.add('past-date');
                        } else if (normalizedActualCellDate.getTime() === todayUTC.getTime()) {
                            dayCell.classList.add('today');
                        }

                        const eventsWrapper = document.createElement('div'); eventsWrapper.className = 'events-wrapper';
                        let cellHasCalculatedPublishEvent = false; let cellHasCalculatedPlanningEvent = false;
                        let cellHasStaticPublishEvent = false; let cellHasStaticPlanningEvent = false;
                        let cellIsPublicHoliday = isPublicHoliday(actualCellDate);
                        let hasAnyEventForHighlighting = false;
                        let cellEventDetails = []; // Array to store event details for the tooltip

                        // Loop through calculated bid period data
                        allBidPeriodData.forEach((period, periodIndex) => {
                            Object.keys(eventTypes).forEach(eventTypeKey => {
                                const eventDate = period[eventTypeKey];
                                if (eventDate && eventDate instanceof Date && !isNaN(eventDate.getTime())) {
                                    if (eventDate.getUTCFullYear() === actualCellDate.getUTCFullYear() &&
                                        eventDate.getUTCMonth() === actualCellDate.getUTCMonth() &&
                                        eventDate.getUTCDate() === actualCellDate.getUTCDate()) {
                                        
                                        const bidPeriodMonthAbbrev = period.bidPeriodName.substring(0, 3);
                                        const eventLabelKey = eventTypeKey;
                                        // Check visibility first
                                        if (appSettings.eventTypeVisibility && appSettings.eventTypeVisibility[eventLabelKey] !== false) {
                                            let baseLabel = (appSettings.headerDisplayNames && appSettings.headerDisplayNames[eventLabelKey]) 
                                                            ? appSettings.headerDisplayNames[eventLabelKey] 
                                                            : eventTypes[eventLabelKey].label;
                                            
                                            let eventDisplayText = baseLabel.includes('%M') 
                                                                    ? baseLabel.replace('%M', `(${bidPeriodMonthAbbrev})`) 
                                                                    : `${baseLabel} (${bidPeriodMonthAbbrev})`;

                                            const eventTextDiv = document.createElement('div'); 
                                            eventTextDiv.className = 'event-text-in-cell';
                                            
                                            // Check if this is a past event (before today)
                                            const isPastEvent = eventDate.getTime() < todayUTC.getTime();
                                            
                                            // Apply opacity styling for past events
                                            if (isPastEvent) {
                                                eventTextDiv.style.opacity = '0.6'; // Reduced opacity for past events
                                                eventTextDiv.classList.add('past-event'); // Add class for potential additional styling
                                            }
                                            // For display in cell, use the HTML version if needed (for abbr span)
                                            let actualLabelHtmlInCell;
                                             if (baseLabel.includes('%M')) {
                                                actualLabelHtmlInCell = baseLabel.replace('%M', `<span class="event-month-abbr">(${bidPeriodMonthAbbrev})</span>`);
                                            } else {
                                                actualLabelHtmlInCell = `${baseLabel}\u00A0<span class="event-month-abbr">(${bidPeriodMonthAbbrev})</span>`;
                                            }
                                            eventTextDiv.innerHTML = actualLabelHtmlInCell;
                                            
                                            // For tooltip, use a simpler text format
                                            cellEventDetails.push(`${eventTypes[eventTypeKey].label} for ${period.bidPeriodName}`);
                                            
                                            eventsWrapper.appendChild(eventTextDiv); hasAnyEventForHighlighting = true;
                                            if (eventTypeKey === 'techCrewPublish' || eventTypeKey === 'cabinCrewPublish') { cellHasCalculatedPublishEvent = true; }
                                            else { cellHasCalculatedPlanningEvent = true; }
                                        }
                                    }
                                } else if (eventDate) {
                                     console.warn(`DEBUG: renderCalendarView - Invalid or non-Date object for ${eventTypeKey} in period ${period.bidPeriodName}:`, eventDate);
                                     // Try to fix invalid date objects
                                     if (typeof eventDate === 'string' || eventDate instanceof String) {
                                        try {
                                            period[eventTypeKey] = new Date(eventDate);
                                            console.log(`Attempted to fix ${eventTypeKey} date for ${period.bidPeriodName}`);
                                        } catch (e) {
                                            console.error(`Failed to convert string to date for ${eventTypeKey}:`, e);
                                        }
                                     }
                                }
                            });
                        });

                        if (cellIsPublicHoliday && (appSettings.eventTypeVisibility && appSettings.eventTypeVisibility.publicHoliday !== false)) {
                            const holidayName = getPublicHolidayName(formatDateForCalc(actualCellDate));
                            // Only add "PH" text if no other *visible* event text is there.
                            // Check if eventsWrapper is empty or only contains hidden events.
                            let onlyHiddenEventsPresent = true;
                            if (eventsWrapper.childNodes.length > 0) {
                                // This check is a bit simplistic. If an event type was hidden, its div wouldn't be added.
                                // So, if eventsWrapper has children, it means at least one visible event was added.
                                onlyHiddenEventsPresent = false; 
                            }

                            if (onlyHiddenEventsPresent) { 
                                const eventTextDiv = document.createElement('div'); eventTextDiv.className = 'event-text-in-cell';
                                eventTextDiv.textContent = "PH"; // Display "PH" in the cell
                                eventsWrapper.appendChild(eventTextDiv);
                                hasAnyEventForHighlighting = true; // PH itself is an event for highlighting
                            }
                            cellEventDetails.push(holidayName); // Full name for tooltip
                        }
                        
                        if (cellEventDetails.length > 0) {
                            const tooltipText = cellEventDetails.join('\n');
                            dayCell.addEventListener('mouseover', (event) => showEventTooltip(event, tooltipText));
                            dayCell.addEventListener('mouseout', hideEventTooltip);
                        }

                        // Apply background colors based on visible events
                        // Check for specific event types first (most specific to least specific)
                        if (cellIsPublicHoliday && (appSettings.eventTypeVisibility?.publicHoliday !== false)) {
                            dayCell.classList.add(cellHighlightClasses.publicHoliday);
                            dayCell.style.backgroundColor = appSettings.colors?.holiday || '#f3f4f6';
                        } else if (cellHasCalculatedPublishEvent) {
                            // Publish events (tech/cabin crew publish)
                            dayCell.classList.add(cellHighlightClasses.publish);
                            dayCell.style.backgroundColor = appSettings.colors?.publish || '#fef9c3';
                        } else if (cellEventDetails.some(detail => 
                            detail.includes('Training Handover') || 
                            detail.includes('Train H/O'))) {
                            // Training Handover events
                            dayCell.style.backgroundColor = appSettings.colors?.trainingHandoverColor || '#e9d5ff';
                        } else if (cellEventDetails.some(detail => 
                            detail.includes('CB Pub Tech') || 
                            detail.includes('CB Pub Cabin'))) {
                            // CB Pairing Publish events
                            dayCell.style.backgroundColor = appSettings.colors?.cbPairingPublishColor || '#99f6e4';
                        } else if (cellEventDetails.some(detail => 
                            detail.includes('Bid Close Tech') || 
                            detail.includes('Bid Close Cabin'))) {
                            // Bidding Closure events
                            dayCell.style.backgroundColor = appSettings.colors?.biddingClosureColor || '#fed7aa';
                        } else if (cellEventDetails.some(detail => 
                            detail.includes('Roster Build Tech') || 
                            detail.includes('Roster Build Cabin'))) {
                            // Roster Build Commence events
                            dayCell.style.backgroundColor = appSettings.colors?.rosterBuildCommenceColor || '#bbf7d0';
                        } else if (cellHasCalculatedPlanningEvent) {
                            // Default planning events (catch-all for other planning events)
                            dayCell.classList.add(cellHighlightClasses.planning);
                            dayCell.style.backgroundColor = appSettings.colors?.planning || '#e0f2fe';
                        }
                        dayCell.appendChild(eventsWrapper);
                    } else {
                        dayCell.classList.add('empty-day');
                    }
                    calendarGridContainer.appendChild(dayCell);
                }
                // Advance to the next roster period definition for the next row
                currentRosterDefIndex = (currentRosterDefIndex + 1) % standardRosterPeriodDefinitions.length;
                if (currentRosterDefIndex === 0) { // Wrapped around from Dec to Jan
                    currentRosterYear++;
                }
            }
            updateEmptyStateMessages();
        }

        function populateCalendarLegend() {
            const legendContainer = document.getElementById('calendarLegend');
            legendContainer.innerHTML = `
                <div class="w-full">
                    <div class="text-xs font-medium text-gray-700 mb-1">Legend</div>
                    <div class="grid grid-cols-4 gap-0.5 text-xs">
                        <div class="legend-item flex items-center"><span class="legend-color" style="background-color: ${appSettings.colors?.publish || '#fef9c3'}"></span>Publish</div>
                        <div class="legend-item flex items-center"><span class="legend-color" style="background-color: ${appSettings.colors?.planning || '#e0f2fe'}"></span>Planning</div>
                        <div class="legend-item flex items-center"><span class="legend-color" style="background-color: ${appSettings.colors?.trainingHandoverColor || '#e9d5ff'}"></span>Train H/O</div>
                        <div class="legend-item flex items-center"><span class="legend-color" style="background-color: ${appSettings.colors?.cbPairingPublishColor || '#99f6e4'}"></span>CB Publish</div>
                        <div class="legend-item flex items-center"><span class="legend-color" style="background-color: ${appSettings.colors?.biddingClosureColor || '#fed7aa'}"></span>Bid Close</div>
                        <div class="legend-item flex items-center"><span class="legend-color" style="background-color: ${appSettings.colors?.rosterBuildCommenceColor || '#bbf7d0'}"></span>Roster Build</div>
                        <div class="legend-item flex items-center"><span class="legend-color" style="background-color: ${appSettings.colors?.holiday || '#f3f4f6'}"></span>Holiday</div>
                        <div class="legend-item flex items-center"><span class="legend-color weekend-text-indicator">##</span>Weekend</div>
                    </div>
                </div>`;
        }
        
        function updateEmptyStateMessages() {
            const noResults = allBidPeriodData.length === 0;
            document.getElementById('noResultsMessage').style.display = noResults ? 'block' : 'none';
            document.getElementById('noCalendarDataMessage').style.display = noResults ? 'block' : 'none';
        }
        
        // --- Static Reference Table Population ---
        function populateStaticReferenceTable() {
            const staticBody = document.getElementById('staticReferenceBody');
            staticBody.innerHTML = ''; 
            staticReferenceDataSource.forEach(item => {
                const row = staticBody.insertRow();
                row.insertCell().textContent = item.bid;
                row.insertCell().textContent = item.spc;
                row.insertCell().textContent = item.spf;
                row.insertCell().textContent = item.tod;
                row.insertCell().textContent = item.ssim;
                row.insertCell().textContent = item.tcp;
                row.insertCell().textContent = item.ccp;
                 Array.from(row.cells).forEach(cell => cell.className = 'px-4 py-3 whitespace-nowrap text-sm text-gray-500');
            });
        }
        
        function populateRosterPeriodsReference(yearToDisplay = new Date().getFullYear()) {
            const rosterBody = document.getElementById('rosterPeriodsReferenceBody');
            const yearDisplaySpan = document.getElementById('rosterReferenceYearDisplay');
            if (!rosterBody || !yearDisplaySpan) return;

            rosterBody.innerHTML = '';
            yearDisplaySpan.textContent = yearToDisplay;
            
            standardRosterPeriodDefinitions.forEach(def => {
                const row = rosterBody.insertRow();
                row.insertCell().textContent = def.period; 
                row.insertCell().textContent = formatDateForInput(parseDate(def.startRule(yearToDisplay)));
                row.insertCell().textContent = formatDateForInput(parseDate(def.endRule(yearToDisplay)));
                row.insertCell().textContent = typeof def.days === 'function' ? def.days(yearToDisplay) : def.days;
                Array.from(row.cells).forEach(cell => cell.className = 'px-2 py-2');
            });
        }

        function changeRosterReferenceYear(offset) {
            rosterReferenceCurrentYear += offset;
            populateRosterPeriodsReference(rosterReferenceCurrentYear); 
        }


        // --- Edit Modal Functions ---
        function openEditModal(periodId) {
            console.log('DEBUG: openEditModal called with periodId:', periodId);
            const period = allBidPeriodData.find(p => p.id === periodId);
            console.log('DEBUG: openEditModal - Period found:', JSON.parse(JSON.stringify(period)));

            if (!period) {
                showToast("Error: Could not find period data to edit.", 3000);
                console.error('DEBUG: openEditModal - Period not found for ID:', periodId);
                return;
            }

            try {
                const modalTitleEl = document.getElementById('editModalTitle');
                console.log('DEBUG: openEditModal - modalTitleEl:', modalTitleEl);
                if (modalTitleEl) modalTitleEl.textContent = `Edit Dates for: ${period.bidPeriodName}`;

                const periodIdEl = document.getElementById('editPeriodId');
                console.log('DEBUG: openEditModal - periodIdEl:', periodIdEl);
                if (periodIdEl) periodIdEl.value = period.id;
                
                const bidPeriodNameHiddenEl = document.getElementById('editBidPeriodNameHidden');
                console.log('DEBUG: openEditModal - bidPeriodNameHiddenEl:', bidPeriodNameHiddenEl);
                if (bidPeriodNameHiddenEl) bidPeriodNameHiddenEl.value = period.bidPeriodName;

                console.log('DEBUG: openEditModal - Populating date fields. Roster Start:', period.rosterStart);
                document.getElementById('editRosterStartDate').value = formatDateForInput(period.rosterStart);
                document.getElementById('editRosterEndDate').value = formatDateForInput(period.rosterEnd);
                document.getElementById('editSpCutoffDate').value = formatDateForInput(period.spCutoff);
                document.getElementById('editSpFeedbackDate').value = formatDateForInput(period.spFeedback);
                document.getElementById('editTradeOffDiscussionDate').value = formatDateForInput(period.tradeOffDiscussion);
                document.getElementById('editFinalSSIMHandoverDate').value = formatDateForInput(period.finalSSIMHandover);
                document.getElementById('editTechCrewPublishDate').value = formatDateForInput(period.techCrewPublish);
                document.getElementById('editCabinCrewPublishDate').value = formatDateForInput(period.cabinCrewPublish);
                document.getElementById('editApprovalStatus').value = period.approvalStatus || 'Pending';
                updateApprovalStatusButtons(); // Update toggle button states
                console.log('DEBUG: openEditModal - Date fields populated.');

                const modalOverlayEl = document.getElementById('editModalOverlay');
                if (modalOverlayEl) {
                    modalOverlayEl.classList.add('active');
                    console.log('DEBUG: openEditModal - "active" class added to modalOverlayEl.');
                } else {
                    console.error('DEBUG: openEditModal - modalOverlayEl not found!');
                }
            } catch (error) {
                console.error('DEBUG: openEditModal - Error during execution:', error);
                showToast("Error opening edit dialog. Check console.", 4000);
            }
        }

        function closeEditModal() {
            const modalOverlayEl = document.getElementById('editModalOverlay');
            if (modalOverlayEl) {
                modalOverlayEl.classList.remove('active');
                console.log('DEBUG: closeEditModal - "active" class removed.');
            }
        }

        function setApprovalStatus(status) {
            document.getElementById('editApprovalStatus').value = status;
            updateApprovalStatusButtons();
        }

        function updateApprovalStatusButtons() {
            const currentStatus = document.getElementById('editApprovalStatus').value;
            const pendingBtn = document.getElementById('statusBtnPending');
            const approvedBtn = document.getElementById('statusBtnApproved');

            if (currentStatus === 'Pending') {
                pendingBtn.className = 'flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 border-2 status-btn-pending';
                approvedBtn.className = 'flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 border-2 status-btn-approved inactive';
            } else {
                pendingBtn.className = 'flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 border-2 status-btn-pending inactive';
                approvedBtn.className = 'flex-1 py-2 px-4 rounded-md text-sm font-semibold transition-all duration-200 border-2 status-btn-approved';
            }
        }

        function toggleRecalculateTools() {
            const content = document.getElementById('recalculateToolsContent');
            const icon = document.getElementById('recalcToolsIcon');

            if (content.classList.contains('hidden')) {
                content.classList.remove('hidden');
                icon.style.transform = 'rotate(90deg)';
            } else {
                content.classList.add('hidden');
                icon.style.transform = 'rotate(0deg)';
            }
        }

        function deleteBidPeriod() {
            const periodId = document.getElementById('editPeriodId').value;
            if (confirm("Are you sure you want to delete this bid period? This action cannot be undone.")) {
                allBidPeriodData = allBidPeriodData.filter(p => p.id != periodId); 
                renderResultsTable();
                renderCalendarView();
                updateEmptyStateMessages();
                populateBidMonthDropdown(parseInt(document.getElementById('selectBidYear').value));
                closeEditModal();
                showToast("Bid period deleted.", 2000);
                saveBidPeriodData(); // Save after deleting
            }
        }

        function recalculateDatesInModal() {
            const spCutoffStr = document.getElementById('editSpCutoffDate').value;
            const rosterStartStr = document.getElementById('editRosterStartDate').value;

            if (!spCutoffStr || !rosterStartStr) {
                showToast("SP Cutoff and Roster Start Date must be set in modal to recalculate.", 3500);
                return;
            }
            try {
                const spFeedbackDate = addWorkingDays(spCutoffStr, appSettings.spFeedbackOffset);
                document.getElementById('editSpFeedbackDate').value = formatDateForInput(spFeedbackDate);

                const tradeOffDiscussionDate = addWorkingDays(formatDateForCalc(spFeedbackDate), appSettings.tradeOffOffset);
                document.getElementById('editTradeOffDiscussionDate').value = formatDateForInput(tradeOffDiscussionDate);

                let finalSSIMHandoverDate = addWorkingDays(formatDateForCalc(tradeOffDiscussionDate), appSettings.ssimHandoverOffset);
                if (appSettings.ssimFridayRule && finalSSIMHandoverDate.getUTCDay() === FRIDAY) {
                    let prevDay = new Date(finalSSIMHandoverDate.getTime()); prevDay.setUTCDate(prevDay.getUTCDate() - 1);
                    finalSSIMHandoverDate = getFinalAdjustedDate(formatDateForCalc(prevDay));
                }
                document.getElementById('editFinalSSIMHandoverDate').value = formatDateForInput(finalSSIMHandoverDate);

                const eomPriorRoster = getEOMPriorRoster(rosterStartStr);
                if (!eomPriorRoster) throw new Error("Could not determine EOM Prior Roster for recalculation.");

                const baseTechCrewPublishDate = new Date(eomPriorRoster.getTime()); baseTechCrewPublishDate.setUTCDate(baseTechCrewPublishDate.getUTCDate() - appSettings.techCrewPublishOffset);
                document.getElementById('editTechCrewPublishDate').value = formatDateForInput(getFinalAdjustedDate(formatDateForCalc(baseTechCrewPublishDate)));

                const baseCabinCrewPublishDate = new Date(eomPriorRoster.getTime()); baseCabinCrewPublishDate.setUTCDate(baseCabinCrewPublishDate.getUTCDate() - appSettings.cabinCrewPublishOffset);
                document.getElementById('editCabinCrewPublishDate').value = formatDateForInput(getFinalAdjustedDate(formatDateForCalc(baseCabinCrewPublishDate)));
                
                showToast("Dependent dates recalculated in modal.", 2000);
            } catch (error) {
                showToast(`Error during modal recalculation: ${error.message}`, 3500);
                console.error("Modal recalculation error:", error);
            }
        }

        // Backward recalculation: When user adjusts Final SSIM Handover, calculate backward
        function recalculateBackwardFromSSIM() {
            const ssimHandoverStr = document.getElementById('editFinalSSIMHandoverDate').value;
            const rosterStartStr = document.getElementById('editRosterStartDate').value;

            if (!ssimHandoverStr) {
                showToast("Final SSIM Handover date must be set to recalculate backward.", 3500);
                return;
            }

            try {
                // Calculate Trade Off Discussion: SSIM Handover - ssimHandoverOffset working days
                const tradeOffDate = subtractWorkingDays(ssimHandoverStr, appSettings.ssimHandoverOffset);
                if (tradeOffDate) {
                    document.getElementById('editTradeOffDiscussionDate').value = formatDateForInput(tradeOffDate);
                }

                // Calculate SP Feedback: Trade Off - tradeOffOffset working days
                const spFeedbackDate = subtractWorkingDays(formatDateForCalc(tradeOffDate), appSettings.tradeOffOffset);
                if (spFeedbackDate) {
                    document.getElementById('editSpFeedbackDate').value = formatDateForInput(spFeedbackDate);
                }

                // Calculate SP Cutoff: SP Feedback - spFeedbackOffset working days
                const spCutoffDate = subtractWorkingDays(formatDateForCalc(spFeedbackDate), appSettings.spFeedbackOffset);
                if (spCutoffDate) {
                    document.getElementById('editSpCutoffDate').value = formatDateForInput(spCutoffDate);
                }

                // Mark the period as manually modified (will be saved when Save Changes is clicked)
                const periodId = document.getElementById('editPeriodId').value;
                const periodIndex = allBidPeriodData.findIndex(p => p.id === periodId);
                if (periodIndex !== -1) {
                    // Store temporary flag - will be committed on save
                    document.getElementById('editModalOverlay').dataset.datesModified = 'true';
                }

                showToast("Dates recalculated backward from SSIM Handover.", 2500);
            } catch (error) {
                showToast(`Error during backward recalculation: ${error.message}`, 3500);
                console.error("Backward recalculation error:", error);
            }
        }

        // Event listener setup for SSIM Handover date changes in modal
        function setupSSIMHandoverListener() {
            const ssimInput = document.getElementById('editFinalSSIMHandoverDate');
            if (ssimInput) {
                ssimInput.addEventListener('change', function() {
                    // Show a toast hint about the Recalculate Backward button
                    showToast('Tip: Use "Recalculate Backward" button to adjust earlier dates from this SSIM Handover date.', 3500);
                });
            }
        }

        // Call setup when DOM is ready (will be called in DOMContentLoaded)

        function saveEditedDates() {
            const periodId = document.getElementById('editPeriodId').value;
            const originalBidPeriodName = document.getElementById('editBidPeriodNameHidden').value;
            const periodIndex = allBidPeriodData.findIndex(p => p.id === periodId); 

            if (periodIndex === -1) {
                showToast("Error: Could not save changes. Period not found.", 3000);
                closeEditModal();
                return;
            }

            try {
                const editedRosterStart = parseDate(document.getElementById('editRosterStartDate').value);
                const editedRosterEnd = parseDate(document.getElementById('editRosterEndDate').value);
                const editedSpCutoff = parseDate(document.getElementById('editSpCutoffDate').value);

                if (!editedRosterStart || !editedRosterEnd || !editedSpCutoff) {
                    throw new Error("Roster Start, Roster End, and SP Cutoff dates cannot be empty and must be valid.");
                }
                if (editedRosterEnd <= editedRosterStart) {
                    throw new Error('Edited Roster End Date must be after Roster Start Date.');
                }
                if (editedSpCutoff >= editedRosterStart) {
                    throw new Error('Edited SP Cutoff Date must be before Roster Start Date.');
                }

                allBidPeriodData[periodIndex].bidPeriodName = originalBidPeriodName;
                allBidPeriodData[periodIndex].rosterStart = editedRosterStart;
                allBidPeriodData[periodIndex].rosterEnd = editedRosterEnd;
                allBidPeriodData[periodIndex].spCutoff = editedSpCutoff;
                allBidPeriodData[periodIndex].spFeedback = parseDate(document.getElementById('editSpFeedbackDate').value) || allBidPeriodData[periodIndex].spFeedback;
                allBidPeriodData[periodIndex].tradeOffDiscussion = parseDate(document.getElementById('editTradeOffDiscussionDate').value) || allBidPeriodData[periodIndex].tradeOffDiscussion;
                allBidPeriodData[periodIndex].finalSSIMHandover = parseDate(document.getElementById('editFinalSSIMHandoverDate').value) || allBidPeriodData[periodIndex].finalSSIMHandover;
                allBidPeriodData[periodIndex].techCrewPublish = parseDate(document.getElementById('editTechCrewPublishDate').value) || allBidPeriodData[periodIndex].techCrewPublish;
                allBidPeriodData[periodIndex].cabinCrewPublish = parseDate(document.getElementById('editCabinCrewPublishDate').value) || allBidPeriodData[periodIndex].cabinCrewPublish;
                allBidPeriodData[periodIndex].approvalStatus = document.getElementById('editApprovalStatus').value; // Save approval status

                // Track if dates were manually modified (backward recalculation or manual edit)
                const modalOverlay = document.getElementById('editModalOverlay');
                if (modalOverlay && modalOverlay.dataset.datesModified === 'true') {
                    allBidPeriodData[periodIndex].datesManuallyModified = true;
                    allBidPeriodData[periodIndex].lastModifiedDate = new Date().toISOString();
                    // Clear the flag for next edit
                    delete modalOverlay.dataset.datesModified;
                }
                
                const periodEventDates = [editedSpCutoff, allBidPeriodData[periodIndex].spFeedback, allBidPeriodData[periodIndex].tradeOffDiscussion, allBidPeriodData[periodIndex].finalSSIMHandover, allBidPeriodData[periodIndex].techCrewPublish, allBidPeriodData[periodIndex].cabinCrewPublish].filter(Boolean);
                const earliestEvent = new Date(Math.min(...periodEventDates.map(d => d.getTime())));
                const latestEvent = new Date(Math.max(...periodEventDates.map(d => d.getTime())));
                const affectedHolidaysList = [];
                if (earliestEvent && latestEvent && !isNaN(earliestEvent.getTime()) && !isNaN(latestEvent.getTime())) {
                    for (let d = new Date(earliestEvent); d <= latestEvent; d.setUTCDate(d.getUTCDate() + 1)) {
                        const dStr = formatDateForCalc(new Date(d));
                        if (melbournePublicHolidays.some(h => h.date === dStr)) { 
                            affectedHolidaysList.push({date: dStr, name: getPublicHolidayName(dStr)});
                        }
                    }
                }
                allBidPeriodData[periodIndex].affectedHolidays = affectedHolidaysList;


                // Normalize property names and ensure rosterStart is a valid Date for sorting
                console.log('SAVE_EDITED_DATES: Normalizing and filtering allBidPeriodData before sort. Current size:', allBidPeriodData.length);
                allBidPeriodData = allBidPeriodData.map(period => {
                    const normalizedPeriod = { ...period }; // Shallow copy

                    // Normalize startDate/endDate to rosterStart/rosterEnd
                    if (normalizedPeriod.startDate && typeof normalizedPeriod.rosterStart === 'undefined') {
                        normalizedPeriod.rosterStart = normalizedPeriod.startDate;
                        delete normalizedPeriod.startDate; // Clean up old property
                    }
                    if (normalizedPeriod.endDate && typeof normalizedPeriod.rosterEnd === 'undefined') {
                        normalizedPeriod.rosterEnd = normalizedPeriod.endDate;
                        delete normalizedPeriod.endDate; // Clean up old property
                    }

                    // Ensure rosterStart is a Date object
                    if (normalizedPeriod.rosterStart && !(normalizedPeriod.rosterStart instanceof Date)) {
                        const parsedDate = new Date(normalizedPeriod.rosterStart);
                        if (parsedDate instanceof Date && !isNaN(parsedDate.getTime())) {
                            normalizedPeriod.rosterStart = parsedDate;
                        } else {
                            console.warn(`SAVE_EDITED_DATES: Invalid date string for rosterStart: '${normalizedPeriod.rosterStart}' in period ID '${normalizedPeriod.id}'. Marking for filtering.`);
                            normalizedPeriod.rosterStart = null; // Mark as invalid
                        }
                    }
                    
                    // Ensure rosterEnd is a Date object (though not used in this sort, good for consistency)
                    if (normalizedPeriod.rosterEnd && !(normalizedPeriod.rosterEnd instanceof Date)) {
                        const parsedEndDate = new Date(normalizedPeriod.rosterEnd);
                        if (parsedEndDate instanceof Date && !isNaN(parsedEndDate.getTime())) {
                            normalizedPeriod.rosterEnd = parsedEndDate;
                        } else {
                            console.warn(`SAVE_EDITED_DATES: Invalid date string for rosterEnd: '${normalizedPeriod.rosterEnd}' in period ID '${normalizedPeriod.id}'. Setting to null.`);
                            normalizedPeriod.rosterEnd = null; 
                        }
                    }
                    return normalizedPeriod;
                }).filter(period => {
                    const isValidForSort = period.rosterStart instanceof Date && !isNaN(period.rosterStart.getTime());
                    const hasBidPeriodName = typeof period.bidPeriodName === 'string' && period.bidPeriodName.trim() !== '';

                    if (!isValidForSort) {
                        console.warn(`SAVE_EDITED_DATES: Filtering out period ID '${period.id || 'N/A'}' due to missing or invalid rosterStart. Period data:`, JSON.parse(JSON.stringify(period)));
                    }
                    // Log missing bidPeriodName only if rosterStart was valid
                    if (!hasBidPeriodName && isValidForSort) { 
                        console.warn(`SAVE_EDITED_DATES: Filtering out period ID '${period.id || 'N/A'}' due to missing or invalid bidPeriodName. Period data:`, JSON.parse(JSON.stringify(period)));
                    }
                    return isValidForSort && hasBidPeriodName;
                });
                console.log('SAVE_EDITED_DATES: Normalization and filtering complete. New size:', allBidPeriodData.length);

                // Use a safer sort with try/catch
                try {
                    allBidPeriodData.sort((a, b) => a.rosterStart.getTime() - b.rosterStart.getTime());
                } catch (err) {
                    console.error('Sort error in addBidPeriod:', err);
                }

                renderResultsTable();
                renderCalendarView();
                closeEditModal();
                populateBidMonthDropdown(parseInt(document.getElementById('selectBidYear').value)); 

                showToast("Dates updated successfully!", 2000);
                saveBidPeriodData(); // Save after editing

            } catch (error) {
                showToast(`Error: ${error.message}`, 4000);
                console.error("Error saving edited dates:", error);
            }
        }
        
        // --- Settings Page Logic ---
        function initializeHeaderNameTooltips() {
            const tooltipTexts = {
                spCutoffDisplayTooltip: "Text displayed in calendar cells for 'SP Cutoff' dates. Use %M as a placeholder for the bid period month (e.g., 'SP Cutoff (%M)').",
                crewBidDisplayTooltip: "Text displayed for 'Crew Bid' events. (Currently not a standard calculated event type in this tool, but can be customized if used). Use %M for month.",
                spFeedbackDisplayTooltip: "Text for 'SP Feedback' dates. Use %M for month.",
                tradeOffDisplayTooltip: "Text for 'Trade Off Discussion' dates. Use %M for month.",
                ssimHandoverDisplayTooltip: "Text for 'SSIM Handover' dates. Use %M for month.",
                techCrewPublishDisplayTooltip: "Text for 'Tech Crew Publish' dates. Use %M for month.",
                cabinCrewPublishDisplayTooltip: "Text for 'Cabin Crew Publish' dates. Use %M for month."
            };

            document.querySelectorAll('#calendar .info-icon[data-tooltip-id]').forEach(icon => {
                const tooltipId = icon.getAttribute('data-tooltip-id');
                const text = tooltipTexts[tooltipId];
                if (text) {
                    icon.addEventListener('mouseover', (event) => showEventTooltip(event, text));
                    icon.addEventListener('mouseout', hideEventTooltip);
                }
            });
        }

        function initializeSettingsPage() {
            document.getElementById('publicHolidaysTextSettings').value = melbournePublicHolidays.map(h => `${h.date} ${h.name}`).join('\n');
            
            document.getElementById('settingSpCutoffDay').value = appSettings.spCutoffRule.day;
            document.getElementById('settingSpCutoffMonthsPrior').value = appSettings.spCutoffRule.monthsPrior;
            document.getElementById('settingSpCutoffWeekendAdjust').value = appSettings.spCutoffRule.weekendAdjustment;
            
            document.getElementById('settingSpFeedbackOffset').value = appSettings.spFeedbackOffset;
            document.getElementById('settingTradeOffOffset').value = appSettings.tradeOffOffset;
            document.getElementById('settingSsimHandoverOffset').value = appSettings.ssimHandoverOffset;
            document.getElementById('settingSsimFridayRule').checked = appSettings.ssimFridayRule;
            
            document.getElementById('settingTechCrewPublishOffset').value = appSettings.techCrewPublishOffset;
            document.getElementById('settingCabinCrewPublishOffset').value = appSettings.cabinCrewPublishOffset;

            // Initialize new calculation parameter inputs
            document.getElementById('settingTrainingHandoverOffset').value = appSettings.trainingHandoverOffset;
            document.getElementById('settingCbPairingPublishTechOffset').value = appSettings.cbPairingPublishTechOffset;
            document.getElementById('settingBiddingClosureTechOffset').value = appSettings.biddingClosureTechOffset;
            document.getElementById('settingRosterBuildCommenceTechOffset').value = appSettings.rosterBuildCommenceTechOffset;
            document.getElementById('settingRosterBuildCommenceCabinOffset').value = appSettings.rosterBuildCommenceCabinOffset;
            
            // Initialize header display names for new event types
            document.getElementById('trainingHandoverDisplay').value = appSettings.headerDisplayNames?.trainingHandover?.replace(' (%M)', '') || '';
            document.getElementById('cbPairingPublishTechDisplay').value = appSettings.headerDisplayNames?.cbPairingPublishTech?.replace(' (%M)', '') || '';
            document.getElementById('cbPairingPublishCabinDisplay').value = appSettings.headerDisplayNames?.cbPairingPublishCabin?.replace(' (%M)', '') || '';
            document.getElementById('biddingClosureTechDisplay').value = appSettings.headerDisplayNames?.biddingClosureTech?.replace(' (%M)', '') || '';
            document.getElementById('biddingClosureCabinDisplay').value = appSettings.headerDisplayNames?.biddingClosureCabin || '';
            document.getElementById('rosterBuildCommenceTechDisplay').value = appSettings.headerDisplayNames?.rosterBuildCommenceTech?.replace(' (%M)', '') || '';
            document.getElementById('rosterBuildCommenceCabinDisplay').value = appSettings.headerDisplayNames?.rosterBuildCommenceCabin?.replace(' (%M)', '') || '';

            // Initialize color pickers (including new ones)
            document.getElementById('planningColorSetting').value = appSettings.colors?.planning || '#e0f2fe';
            document.getElementById('publishColorSetting').value = appSettings.colors?.publish || '#fef9c3';
            document.getElementById('holidayColorSetting').value = appSettings.colors?.holiday || '#f3f4f6';
            document.getElementById('trainingHandoverColorSetting').value = appSettings.colors?.trainingHandoverColor || '#e9d5ff';
            document.getElementById('cbPairingPublishColorSetting').value = appSettings.colors?.cbPairingPublishColor || '#99f6e4';
            document.getElementById('biddingClosureColorSetting').value = appSettings.colors?.biddingClosureColor || '#fed7aa';
            document.getElementById('rosterBuildCommenceColorSetting').value = appSettings.colors?.rosterBuildCommenceColor || '#bbf7d0';
            
            // Clear all header display name fields by setting them to empty strings
            document.getElementById('trainingHandoverDisplay').value = '';
            document.getElementById('cbPairingPublishTechDisplay').value = '';
            document.getElementById('cbPairingPublishCabinDisplay').value = '';
            document.getElementById('biddingClosureTechDisplay').value = '';
            document.getElementById('biddingClosureCabinDisplay').value = '';
            document.getElementById('rosterBuildCommenceTechDisplay').value = '';
            document.getElementById('rosterBuildCommenceCabinDisplay').value = '';


            // populateRosterPeriodsReference(rosterReferenceCurrentYear); // Removed duplicate call

            const sampleYearSelect = document.getElementById('samplePreviewYear');
            const sampleMonthSelect = document.getElementById('samplePreviewMonth');
            const currentYear = new Date().getFullYear();
            sampleYearSelect.innerHTML = '';
            for (let i = currentYear -1 ; i <= currentYear + 3; i++) {
                const option = document.createElement('option');
                option.value = i; option.textContent = i;
                sampleYearSelect.appendChild(option);
            }
            sampleYearSelect.value = currentYear;
            
            sampleMonthSelect.innerHTML = '';
            Object.keys(monthMap).forEach(monthKey => {
                const option = document.createElement('option');
                option.value = monthKey; option.textContent = monthKey;
                sampleMonthSelect.appendChild(option);
            });
            sampleMonthSelect.value = Object.keys(monthMap)[new Date().getUTCMonth()];
            
            populateRosterPeriodsReference(rosterReferenceCurrentYear); // Added call
            updateRecalculationNotice();
            initializeHeaderNameTooltips(); // Initialize tooltips for header names
        }

        function saveSettings() {
            // Save header display names, ensuring keys match eventTypes
            appSettings.headerDisplayNames = {
                spCutoff: document.getElementById('spCutoffDisplay').value || eventTypes.spCutoff.label,
                spFeedback: document.getElementById('spFeedbackDisplay').value || eventTypes.spFeedback.label,
                tradeOffDiscussion: document.getElementById('tradeOffDisplay').value || eventTypes.tradeOffDiscussion.label,
                finalSSIMHandover: document.getElementById('ssimHandoverDisplay').value || eventTypes.finalSSIMHandover.label,
                techCrewPublish: document.getElementById('techCrewPublishDisplay').value || eventTypes.techCrewPublish.label,
                cabinCrewPublish: document.getElementById('cabinCrewPublishDisplay').value || eventTypes.cabinCrewPublish.label,
                // New header display names - Add (%M) back to the saved values if they don't already have it
                trainingHandover: document.getElementById('trainingHandoverDisplay').value + (document.getElementById('trainingHandoverDisplay').value.includes('(%M)') ? '' : ' (%M)') || eventTypes.trainingHandover.label + " (%M)",
                cbPairingPublishTech: document.getElementById('cbPairingPublishTechDisplay').value + (document.getElementById('cbPairingPublishTechDisplay').value.includes('(%M)') ? '' : ' (%M)') || eventTypes.cbPairingPublishTech.label + " (%M)",
                cbPairingPublishCabin: document.getElementById('cbPairingPublishCabinDisplay').value + (document.getElementById('cbPairingPublishCabinDisplay').value.includes('(%M)') ? '' : ' (%M)') || eventTypes.cbPairingPublishCabin.label + " (%M)",
                biddingClosureTech: document.getElementById('biddingClosureTechDisplay').value + (document.getElementById('biddingClosureTechDisplay').value.includes('(%M)') ? '' : ' (%M)') || eventTypes.biddingClosureTech.label + " (%M)",
                biddingClosureCabin: document.getElementById('biddingClosureCabinDisplay').value || eventTypes.biddingClosureCabin.label,
                rosterBuildCommenceTech: document.getElementById('rosterBuildCommenceTechDisplay').value + (document.getElementById('rosterBuildCommenceTechDisplay').value.includes('(%M)') ? '' : ' (%M)') || eventTypes.rosterBuildCommenceTech.label + " (%M)",
                rosterBuildCommenceCabin: document.getElementById('rosterBuildCommenceCabinDisplay').value + (document.getElementById('rosterBuildCommenceCabinDisplay').value.includes('(%M)') ? '' : ' (%M)') || eventTypes.rosterBuildCommenceCabin.label + " (%M)"
            };
            if (document.getElementById('crewBidDisplay').value) { // Keep existing crewBid logic
                appSettings.headerDisplayNames.crewBid = document.getElementById('crewBidDisplay').value;
            }
            
            // Original settings save logic
            appSettings.spCutoffRule.day = parseInt(document.getElementById('settingSpCutoffDay').value) || 10;
            appSettings.spCutoffRule.monthsPrior = parseInt(document.getElementById('settingSpCutoffMonthsPrior').value) || 2;
            appSettings.spCutoffRule.weekendAdjustment = document.getElementById('settingSpCutoffWeekendAdjust').value;
            
            appSettings.spFeedbackOffset = parseInt(document.getElementById('settingSpFeedbackOffset').value) || 2;
            appSettings.tradeOffOffset = parseInt(document.getElementById('settingTradeOffOffset').value) || 1;
            appSettings.ssimHandoverOffset = parseInt(document.getElementById('settingSsimHandoverOffset').value) || 1;
            appSettings.ssimFridayRule = document.getElementById('settingSsimFridayRule').checked;
            
            appSettings.techCrewPublishOffset = parseInt(document.getElementById('settingTechCrewPublishOffset').value) || 10;
            appSettings.cabinCrewPublishOffset = parseInt(document.getElementById('settingCabinCrewPublishOffset').value) || 7;

            // Save new calculation parameters
            appSettings.trainingHandoverOffset = parseInt(document.getElementById('settingTrainingHandoverOffset').value) || 7;
            appSettings.cbPairingPublishTechOffset = parseInt(document.getElementById('settingCbPairingPublishTechOffset').value) || 2;
            appSettings.biddingClosureTechOffset = parseInt(document.getElementById('settingBiddingClosureTechOffset').value) || 1;
            appSettings.rosterBuildCommenceTechOffset = parseInt(document.getElementById('settingRosterBuildCommenceTechOffset').value) || 12;
            appSettings.rosterBuildCommenceCabinOffset = parseInt(document.getElementById('settingRosterBuildCommenceCabinOffset').value) || 16;

            // Save color settings (including new ones)
            appSettings.colors = appSettings.colors || {};
            appSettings.colors.planning = document.getElementById('planningColorSetting').value || '#e0f2fe';
            appSettings.colors.publish = document.getElementById('publishColorSetting').value || '#fef9c3';
            appSettings.colors.holiday = document.getElementById('holidayColorSetting').value || '#f3f4f6';
            appSettings.colors.trainingHandoverColor = document.getElementById('trainingHandoverColorSetting').value || '#e9d5ff';
            appSettings.colors.cbPairingPublishColor = document.getElementById('cbPairingPublishColorSetting').value || '#99f6e4';
            appSettings.colors.biddingClosureColor = document.getElementById('biddingClosureColorSetting').value || '#fed7aa';
            appSettings.colors.rosterBuildCommenceColor = document.getElementById('rosterBuildCommenceColorSetting').value || '#bbf7d0';

            // Save auto-generation settings
            appSettings.autoGenerateEnabled = document.getElementById('settingAutoGenerateEnabled').checked;
            appSettings.autoGenerateMonthsAhead = parseInt(document.getElementById('settingAutoGenerateMonthsAhead').value) || 18;

            localStorage.setItem('appSettings', JSON.stringify(appSettings));
            
            // Determine active tab
            const activeTabContent = document.querySelector('.tab-content.active');
            const activeTabId = activeTabContent ? activeTabContent.id : null;

            if (activeTabId === 'calendar') {
                populateCalendarLegend(); // Update legend colors if they are dynamic (currently not, but good practice)
                renderCalendarView(); // Re-render calendar with new colors and header names
                showToast("Calendar settings updated!", 2000);
                // No recalculation notice for calendar-only changes
                document.getElementById('recalculationNotice').textContent = ''; 
            } else {
                // Existing logic for other tabs
                populateCalendarLegend(); 
                showToast("Settings saved! Future periods will be recalculated.", 3000);
                updatePublicHolidays(); 
                recalculateFutureBidPeriods(true); // This will call renderCalendarView
                updateRecalculationNotice(); 
            }
        }
        
        function previewSettingChanges() {
            const sampleYear = parseInt(document.getElementById('samplePreviewYear').value);
            const sampleMonthKey = document.getElementById('samplePreviewMonth').value;
            const outputDiv = document.getElementById('settingsSampleOutput');

            if (!sampleMonthKey || !sampleYear) {
                outputDiv.textContent = "Please select a valid sample month and year.";
                return;
            }

            const tempSettings = {
                spCutoffRule: {
                    day: parseInt(document.getElementById('settingSpCutoffDay').value) || 10,
                    monthsPrior: parseInt(document.getElementById('settingSpCutoffMonthsPrior').value) || 2,
                    weekendAdjustment: document.getElementById('settingSpCutoffWeekendAdjust').value
                },
                spFeedbackOffset: parseInt(document.getElementById('settingSpFeedbackOffset').value) || 2,
                tradeOffOffset: parseInt(document.getElementById('settingTradeOffOffset').value) || 1,
                ssimHandoverOffset: parseInt(document.getElementById('settingSsimHandoverOffset').value) || 1,
                ssimFridayRule: document.getElementById('settingSsimFridayRule').checked,
                techCrewPublishOffset: parseInt(document.getElementById('settingTechCrewPublishOffset').value) || 10,
                cabinCrewPublishOffset: parseInt(document.getElementById('settingCabinCrewPublishOffset').value) || 7
            };

            const bidPeriodName = `${sampleMonthKey}-${String(sampleYear).slice(-2)}`;
            const standardRosterDates = getStandardRosterDates(sampleMonthKey, sampleYear);

            if (!standardRosterDates) {
                outputDiv.textContent = `Error: Could not get roster dates for ${bidPeriodName}.`; return;
            }
            const { startDateStr: rosterStartDateStr, endDateStr: rosterEndDateStr } = standardRosterDates;

            const rosterStartDateForSP = parseDate(rosterStartDateStr);
            if (!rosterStartDateForSP) { outputDiv.textContent = "Error parsing roster start for preview."; return; }

            let spCutoffDate = new Date(Date.UTC(rosterStartDateForSP.getUTCFullYear(), rosterStartDateForSP.getUTCMonth() - tempSettings.spCutoffRule.monthsPrior, tempSettings.spCutoffRule.day));
            if (tempSettings.spCutoffRule.weekendAdjustment === 'nextWorkingDay') {
                let dayOfWeek = spCutoffDate.getUTCDay();
                if (dayOfWeek === SATURDAY) { spCutoffDate.setUTCDate(spCutoffDate.getUTCDate() + 2); }
                else if (dayOfWeek === SUNDAY) { spCutoffDate.setUTCDate(spCutoffDate.getUTCDate() + 1); }
                while(isPublicHoliday(spCutoffDate)){ spCutoffDate.setUTCDate(spCutoffDate.getUTCDate() + 1); 
                    dayOfWeek = spCutoffDate.getUTCDay();
                    if (dayOfWeek === SATURDAY) { spCutoffDate.setUTCDate(spCutoffDate.getUTCDate() + 2); }
                    else if (dayOfWeek === SUNDAY) { spCutoffDate.setUTCDate(spCutoffDate.getUTCDate() + 1); }
                }
            } else if (tempSettings.spCutoffRule.weekendAdjustment === 'previousWorkingDay') {
                spCutoffDate = getFinalAdjustedDate(formatDateForInput(spCutoffDate)); 
            }
            const spCutoffDateStr = formatDateForInput(spCutoffDate);

            const spFeedbackDate = addWorkingDays(spCutoffDateStr, tempSettings.spFeedbackOffset);
            const tradeOffDiscussionDate = addWorkingDays(formatDateForCalc(spFeedbackDate), tempSettings.tradeOffOffset);
            let finalSSIMHandoverDate = addWorkingDays(formatDateForCalc(tradeOffDiscussionDate), tempSettings.ssimHandoverOffset);
            if (tempSettings.ssimFridayRule && finalSSIMHandoverDate.getUTCDay() === FRIDAY) {
                let prevDay = new Date(finalSSIMHandoverDate.getTime()); prevDay.setUTCDate(prevDay.getUTCDate() - 1);
                finalSSIMHandoverDate = getFinalAdjustedDate(formatDateForCalc(prevDay));
            }
            const eomPriorRoster = getEOMPriorRoster(rosterStartDateStr);
            const baseTechCrewPublishDate = new Date(eomPriorRoster.getTime()); baseTechCrewPublishDate.setUTCDate(baseTechCrewPublishDate.getUTCDate() - tempSettings.techCrewPublishOffset);
            const finalTechCrewPublishDate = getFinalAdjustedDate(formatDateForCalc(baseTechCrewPublishDate));

            const baseCabinCrewPublishDate = new Date(eomPriorRoster.getTime()); baseCabinCrewPublishDate.setUTCDate(baseCabinCrewPublishDate.getUTCDate() - tempSettings.cabinCrewPublishOffset);
            const finalCabinCrewPublishDate = getFinalAdjustedDate(formatDateForCalc(baseCabinCrewPublishDate));

            outputDiv.innerHTML = `<strong>Preview for ${bidPeriodName}:</strong>
Roster: ${formatDate(rosterStartDateStr)} - ${formatDate(rosterEndDateStr)}
SP Cutoff: ${formatDate(spCutoffDateStr)}
SP Feedback: ${formatDate(spFeedbackDate)}
Trade Off: ${formatDate(tradeOffDiscussionDate)}
SSIM Handover: ${formatDate(finalSSIMHandoverDate)}
Tech Publish: ${formatDate(finalTechCrewPublishDate)}
Cabin Publish: ${formatDate(finalCabinCrewPublishDate)}`;
            updateRecalculationNotice();
        }


        function recalculateFutureBidPeriods(settingsChanged = false) {
            const today = new Date(); 
            today.setUTCHours(0,0,0,0); 

            const updatedData = allBidPeriodData.map(period => {
                if (period.rosterStart.getTime() >= today.getTime() || settingsChanged) {
                    // Create a fresh period object with all necessary properties
                    const updatedPeriod = {
                        ...period,
                        // Initialize new event types if they don't exist
                        trainingHandoverTech: period.trainingHandoverTech || null,
                        trainingHandoverCabin: period.trainingHandoverCabin || null,
                        rosterBuildCommenceTech: period.rosterBuildCommenceTech || null,
                        rosterBuildCommenceCabin: period.rosterBuildCommenceCabin || null,
                        biddingClosureTech: period.biddingClosureTech || null,
                        biddingClosureCabin: period.biddingClosureCabin || null,
                        cbPairingPublishTech: period.cbPairingPublishTech || null,
                        cbPairingPublishCabin: period.cbPairingPublishCabin || null
                    };
                    
                    // Calculate base dates
                    let newSpCutoffDate = updatedPeriod.spCutoff; 
                    if (settingsChanged) { 
                        const rosterStartDateForSP = updatedPeriod.rosterStart;
                        let spCutoffSuggestion;

                        if (updatedPeriod.bidPeriodName.startsWith("Feb-")) { // Special rule for Feb
                            spCutoffSuggestion = new Date(Date.UTC(rosterStartDateForSP.getUTCFullYear(), monthMap['Dec'] -12, appSettings.spCutoffRule.day));
                        } else {
                            spCutoffSuggestion = new Date(Date.UTC(rosterStartDateForSP.getUTCFullYear(), rosterStartDateForSP.getUTCMonth() - appSettings.spCutoffRule.monthsPrior, appSettings.spCutoffRule.day));
                        }
                        
                        if (appSettings.spCutoffRule.weekendAdjustment === 'nextWorkingDay') {
                            let dayOfWeek = spCutoffSuggestion.getUTCDay();
                            if (dayOfWeek === SATURDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 2); }
                            else if (dayOfWeek === SUNDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 1); }
                            while(isPublicHoliday(spCutoffSuggestion)){ spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 1); 
                                dayOfWeek = spCutoffSuggestion.getUTCDay();
                                if (dayOfWeek === SATURDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 2); }
                                else if (dayOfWeek === SUNDAY) { spCutoffSuggestion.setUTCDate(spCutoffSuggestion.getUTCDate() + 1); }
                            }
                        } else if (appSettings.spCutoffRule.weekendAdjustment === 'previousWorkingDay') {
                            spCutoffSuggestion = getFinalAdjustedDate(formatDateForInput(spCutoffSuggestion));
                        }
                        newSpCutoffDate = spCutoffSuggestion;
                    }

                    updatedPeriod.spCutoff = newSpCutoffDate;
                    updatedPeriod.spFeedback = addWorkingDays(formatDateForCalc(newSpCutoffDate), appSettings.spFeedbackOffset);
                    updatedPeriod.tradeOffDiscussion = addWorkingDays(formatDateForCalc(updatedPeriod.spFeedback), appSettings.tradeOffOffset);
                    updatedPeriod.finalSSIMHandover = addWorkingDays(formatDateForCalc(updatedPeriod.tradeOffDiscussion), appSettings.ssimHandoverOffset);
                    
                    if (appSettings.ssimFridayRule && updatedPeriod.finalSSIMHandover.getUTCDay() === FRIDAY) {
                        let prevDay = new Date(updatedPeriod.finalSSIMHandover.getTime()); 
                        prevDay.setUTCDate(prevDay.getUTCDate() - 1);
                        updatedPeriod.finalSSIMHandover = getFinalAdjustedDate(formatDateForCalc(prevDay));
                    }
                    
                    const eomPriorRoster = getEOMPriorRoster(formatDateForCalc(updatedPeriod.rosterStart));
                    
                    // Tech/Cabin Crew Publish dates
                    const baseTechCrewPublishDate = new Date(eomPriorRoster.getTime());
                    baseTechCrewPublishDate.setUTCDate(baseTechCrewPublishDate.getUTCDate() - appSettings.techCrewPublishOffset);
                    updatedPeriod.techCrewPublish = getFinalAdjustedDate(formatDateForCalc(baseTechCrewPublishDate));
                    
                    const baseCabinCrewPublishDate = new Date(eomPriorRoster.getTime());
                    baseCabinCrewPublishDate.setUTCDate(baseCabinCrewPublishDate.getUTCDate() - appSettings.cabinCrewPublishOffset);
                    updatedPeriod.cabinCrewPublish = getFinalAdjustedDate(formatDateForCalc(baseCabinCrewPublishDate));

                    // Now calculate all the new event types
                    
                    // 1. Training Handover
                    if (appSettings.trainingHandoverOffset !== undefined && updatedPeriod.finalSSIMHandover) {
                        const trainingHandoverDate = new Date(updatedPeriod.finalSSIMHandover.getTime());
                        trainingHandoverDate.setUTCDate(trainingHandoverDate.getUTCDate() + appSettings.trainingHandoverOffset);
                        updatedPeriod.trainingHandoverTech = normalizeToUTCMidnight(trainingHandoverDate);
                        updatedPeriod.trainingHandoverCabin = normalizeToUTCMidnight(new Date(trainingHandoverDate.getTime()));
                    }
                    
                    // 2. Roster Build Commence
                    if (appSettings.rosterBuildCommenceTechOffset !== undefined && updatedPeriod.techCrewPublish) {
                        const rosterBuildCommenceTech = new Date(updatedPeriod.techCrewPublish.getTime());
                        rosterBuildCommenceTech.setUTCDate(rosterBuildCommenceTech.getUTCDate() + appSettings.rosterBuildCommenceTechOffset);
                        updatedPeriod.rosterBuildCommenceTech = normalizeToUTCMidnight(rosterBuildCommenceTech);
                    }
                    
                    if (appSettings.rosterBuildCommenceCabinOffset !== undefined && updatedPeriod.cabinCrewPublish) {
                        const rosterBuildCommenceCabin = new Date(updatedPeriod.cabinCrewPublish.getTime());
                        rosterBuildCommenceCabin.setUTCDate(rosterBuildCommenceCabin.getUTCDate() + appSettings.rosterBuildCommenceCabinOffset);
                        updatedPeriod.rosterBuildCommenceCabin = normalizeToUTCMidnight(rosterBuildCommenceCabin);
                    }
                    
                    // 3. Bidding Closure
                    if (appSettings.biddingClosureTechOffset !== undefined && updatedPeriod.rosterBuildCommenceTech) {
                        const biddingClosureTech = new Date(updatedPeriod.rosterBuildCommenceTech.getTime());
                        biddingClosureTech.setUTCDate(biddingClosureTech.getUTCDate() + appSettings.biddingClosureTechOffset);
                        updatedPeriod.biddingClosureTech = normalizeToUTCMidnight(biddingClosureTech);
                    }
                    
                    if (appSettings.biddingClosureCabinOffset !== undefined && updatedPeriod.rosterBuildCommenceCabin) {
                        const biddingClosureCabin = new Date(updatedPeriod.rosterBuildCommenceCabin.getTime());
                        biddingClosureCabin.setUTCDate(biddingClosureCabin.getUTCDate() + appSettings.biddingClosureCabinOffset);
                        updatedPeriod.biddingClosureCabin = normalizeToUTCMidnight(biddingClosureCabin);
                    }
                    
                    // 4. CB Pairing Publish
                    if (appSettings.cbPairingPublishTechOffset !== undefined && updatedPeriod.biddingClosureTech) {
                        updatedPeriod.cbPairingPublishTech = normalizeToUTCMidnight(
                            addWorkingDays(formatDateForCalc(updatedPeriod.biddingClosureTech), appSettings.cbPairingPublishTechOffset)
                        );
                    }
                    
                    if (appSettings.cbPairingPublishCabinOffset !== undefined && updatedPeriod.biddingClosureCabin) {
                        updatedPeriod.cbPairingPublishCabin = normalizeToUTCMidnight(
                            addWorkingDays(formatDateForCalc(updatedPeriod.biddingClosureCabin), appSettings.cbPairingPublishCabinOffset)
                        );
                    }
                    
                    // Calculate affected holidays
                    const allEventDates = [
                        updatedPeriod.spCutoff, 
                        updatedPeriod.spFeedback, 
                        updatedPeriod.tradeOffDiscussion, 
                        updatedPeriod.finalSSIMHandover, 
                        updatedPeriod.techCrewPublish, 
                        updatedPeriod.cabinCrewPublish,
                        updatedPeriod.trainingHandoverTech,
                        updatedPeriod.trainingHandoverCabin,
                        updatedPeriod.rosterBuildCommenceTech,
                        updatedPeriod.rosterBuildCommenceCabin,
                        updatedPeriod.biddingClosureTech,
                        updatedPeriod.biddingClosureCabin,
                        updatedPeriod.cbPairingPublishTech,
                        updatedPeriod.cbPairingPublishCabin
                    ].filter(Boolean);
                    
                    if (allEventDates.length > 0) {
                        const earliestEvent = new Date(Math.min(...allEventDates.map(d => d.getTime())));
                        const latestEvent = new Date(Math.max(...allEventDates.map(d => d.getTime())));
                        const affectedHolidaysList = [];
                        
                        if (earliestEvent && latestEvent && !isNaN(earliestEvent.getTime()) && !isNaN(latestEvent.getTime())) {
                            for (let d = new Date(firstDay); d <= lastDay; d.setDate(d.getDate() + 1)) {
                const cellDate = new Date(d);
                const dateKey = formatDateForCalc(cellDate);
                const dayNumber = cellDate.getDate();
                const dayOfWeek = cellDate.getDay(); // 0 = Sunday, 6 = Saturday
                const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
                const isPastDate = isPastDateFn(cellDate);
                const isToday = isTodayFn(cellDate);
                const isCurrentMonth = cellDate.getUTCMonth() === month;
                const monthClass = isCurrentMonth ? 'current-month' : 'other-month';
                const weekendClass = isWeekend ? 'weekend' : '';
                const todayClass = isToday ? 'today' : '';
                const pastDateClass = isPastDate ? 'past-date' : '';
                
                const dayCell = document.createElement('div');
                dayCell.className = `calendar-grid-day-cell ${monthClass} ${weekendClass} ${todayClass} ${pastDateClass} empty-day`;
                // Add data-day attribute for weekend pill styling
                dayCell.setAttribute('data-day', dayOfWeek);
                const dStr = formatDateForCalc(new Date(d));
                if (melbournePublicHolidays.some(h => h.date === dStr)) {
                    affectedHolidaysList.push({date: dStr, name: getPublicHolidayName(dStr)});
                }
                            }
                        }
                        updatedPeriod.affectedHolidays = affectedHolidaysList;
                    }
                    
                    return updatedPeriod;
                }
                return period; 
            });
            
            allBidPeriodData = updatedData;
            renderResultsTable();
            renderCalendarView();
            populateBidMonthDropdown(parseInt(document.getElementById('selectBidYear').value));
            saveBidPeriodData(); // Save after recalculating
        }
        
        function updateRecalculationNotice() {
            const noticeDiv = document.getElementById('recalculationNotice');
            const today = new Date();
            today.setUTCHours(0,0,0,0);
            const futurePeriodsToRecalculate = allBidPeriodData.filter(p => p.rosterStart.getTime() >= today.getTime());
            
            if (futurePeriodsToRecalculate.length > 0) {
                noticeDiv.textContent = `Note: Saving will recalculate future periods starting from: ${futurePeriodsToRecalculate.map(p => p.bidPeriodName).join(', ')}. Past periods will not be affected.`;
            } else {
                noticeDiv.textContent = "Note: No future periods in the calculated table to be affected by settings changes.";
            }
        }


        // --- Tooltip Functions ---
        function showHolidayTooltip(event, affectedHolidays) {
            hideHolidayTooltip(); 
            hideEventTooltip(); // Add this line

            if (!affectedHolidays || affectedHolidays.length === 0) return;

            let tooltipContent = "Public Holidays:\n";
            affectedHolidays.forEach((h, index) => {
                tooltipContent += `${index + 1}) ${h.date} - ${h.name}\n`;
            });

            currentHolidayTooltip = document.createElement('div');
            currentHolidayTooltip.style.position = 'fixed';
            currentHolidayTooltip.style.left = (event.clientX + 15) + 'px';
            currentHolidayTooltip.style.top = (event.clientY - 10) + 'px';
            currentHolidayTooltip.style.backgroundColor = '#374151'; 
            currentHolidayTooltip.style.color = 'white';
            currentHolidayTooltip.style.padding = '8px 12px';
            currentHolidayTooltip.style.borderRadius = '6px';
            currentHolidayTooltip.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
            currentHolidayTooltip.style.zIndex = '9999'; 
            currentHolidayTooltip.style.fontSize = '0.75rem';
            currentHolidayTooltip.style.whiteSpace = 'pre-line';
            currentHolidayTooltip.style.textAlign = 'left';
            currentHolidayTooltip.textContent = tooltipContent.trim();

            document.body.appendChild(currentHolidayTooltip);
        }

        function hideHolidayTooltip() {
            if (currentHolidayTooltip) {
                currentHolidayTooltip.remove();
                currentHolidayTooltip = null;
            }
        }

        // --- Event Tooltip Functions (similar to holiday tooltip) ---
        function showEventTooltip(event, eventDetailsText) {
            hideEventTooltip(); // Hide any existing event tooltip
            hideHolidayTooltip(); // Add this line

            if (!eventDetailsText || eventDetailsText.trim() === "") return;

            currentEventTooltip = document.createElement('div');
            currentEventTooltip.style.position = 'fixed';
            currentEventTooltip.style.left = (event.clientX + 15) + 'px'; // Offset from cursor
            currentEventTooltip.style.top = (event.clientY - 10) + 'px';  // Offset from cursor
            currentEventTooltip.style.backgroundColor = '#374151'; // Tailwind gray-700
            currentEventTooltip.style.color = 'white';
            currentEventTooltip.style.padding = '8px 12px';
            currentEventTooltip.style.borderRadius = '6px'; // Tailwind rounded-md
            currentEventTooltip.style.boxShadow = '0 2px 8px rgba(0,0,0,0.15)';
            currentEventTooltip.style.zIndex = '10000'; // Ensure it's on top
            currentEventTooltip.style.fontSize = '0.75rem'; // Tailwind text-xs
            currentEventTooltip.style.whiteSpace = 'pre-line'; // Respect newlines in the text
            currentEventTooltip.style.textAlign = 'left';
            currentEventTooltip.textContent = eventDetailsText.trim();

            document.body.appendChild(currentEventTooltip);
        }

        function hideEventTooltip() {
            if (currentEventTooltip) {
                currentEventTooltip.remove();
                currentEventTooltip = null;
            }
        }
        // --- End of Event Tooltip Functions ---


        // --- DOMContentLoaded Event Listener ---
        // Dialog Functions
        function normalizeToUTCMidnight(date) {
            return new Date(Date.UTC(
                date.getUTCFullYear(),
                date.getUTCMonth(),
                date.getUTCDate()
            ));
        }

        function showEditDialog(periodId) {
            const period = allBidPeriodData.find(p => p.id === periodId);
            if (!period) {
                showToast("Error: Could not find period");
                return;
            }
            
            const dialog = document.getElementById('editDialog');
            const overlay = document.getElementById('modalOverlay');
            
            // Populate form fields with local dates for user input
            document.getElementById('editStartDate').value = period.rosterStart.toISOString().split('T')[0]; // Changed to rosterStart
            document.getElementById('editEndDate').value = period.rosterEnd.toISOString().split('T')[0]; // Changed to rosterEnd
            document.getElementById('editPeriodId').value = periodId;
            
            // Show dialog
            overlay.classList.add('active');
            dialog.style.display = 'block';
        }

        function closeEditDialog() {
            const dialog = document.getElementById('editDialog');
            const overlay = document.getElementById('modalOverlay');
            
            overlay.classList.remove('active');
            dialog.style.display = 'none';
        }

        function saveEditDialog() {
            const periodId = document.getElementById('editPeriodId').value;
            const rosterStartDateValue = document.getElementById('editStartDate').value;
            const rosterEndDateValue = document.getElementById('editEndDate').value;

            // Ensure dates are parsed correctly from YYYY-MM-DD input
            const rosterStart = parseDate(rosterStartDateValue);
            const rosterEnd = parseDate(rosterEndDateValue);
            
            if (!rosterStart || !rosterEnd || isNaN(rosterStart.getTime()) || isNaN(rosterEnd.getTime())) {
                showToast('Please enter valid dates');
                return;
            }
            
            const period = allBidPeriodData.find(p => p.id === periodId);
            if (!period) {
                showToast('Error: Could not find period');
                return;
            }
            
            // Assign UTC normalized dates
            period.rosterStart = normalizeToUTCMidnight(rosterStart); // Changed to rosterStart
            period.rosterEnd = normalizeToUTCMidnight(rosterEnd);   // Changed to rosterEnd
            
            // Validate date range
            if (period.rosterEnd < period.rosterStart) { // Changed to rosterEnd and rosterStart
                showToast('End date must be after start date');
                return;
            }
            
            // Update data and close dialog
            updateCalculations();
            closeEditDialog();
            showToast("Changes saved successfully");
        }

        // Data Management Functions

        function generateBidPeriodId() {
            return 'bid_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function applyNoOverlapRule(period) {
            // Define the order of events for the no-overlap rule
            // This should match the logical sequence of events
            const eventOrder = [
                'spCutoff',
                'spFeedback',
                'tradeOffDiscussion',
                'finalSSIMHandover',
                'trainingHandoverTech',
                'trainingHandoverCabin',
                'techCrewPublish',
                'cabinCrewPublish',
                'rosterBuildCommenceTech',
                'biddingClosureTech',
                'cbPairingPublishTech',
                'rosterBuildCommenceCabin',
                'biddingClosureCabin',
                'cbPairingPublishCabin'
            ];

            // Get all events that exist in the period and sort them according to eventOrder
            const significantEvents = eventOrder
                .filter(eventType => period[eventType] instanceof Date)
                .map(eventType => ({
                    type: eventType,
                    date: new Date(period[eventType])
                }));

            // Ensure at least 1 working day between significant events
            for (let i = 1; i < significantEvents.length; i++) {
                const prevEvent = significantEvents[i - 1];
                const currentEvent = significantEvents[i];
                
                const prevDate = new Date(prevEvent.date);
                const currentDate = new Date(currentEvent.date);
                
                // Calculate the minimum allowed date for current event (next working day after previous event)
                const minAllowedDate = addWorkingDays(formatDateForCalc(prevDate), 1);
                
                // If current event is on or before the minimum allowed date
                if (currentDate <= minAllowedDate) {
                    // Move current event to the minimum allowed date
                    period[currentEvent.type] = minAllowedDate;
                    
                    // Update the date in our array to affect subsequent checks
                    currentEvent.date = minAllowedDate;
                    
                    // Log the adjustment for debugging
                    console.log(`Adjusted ${currentEvent.type} to ${minAllowedDate} to avoid overlap with ${prevEvent.type}`);
                }
                
                // Special case: If we have both Tech and Cabin events that might be on the same day
                // but should be separated (e.g., biddingClosureTech and biddingClosureCabin)
                const isSameDay = (date1, date2) => {
                    return date1.getUTCFullYear() === date2.getUTCFullYear() &&
                           date1.getUTCMonth() === date2.getUTCMonth() &&
                           date1.getUTCDate() === date2.getUTCDate();
                };
                
                if (isSameDay(prevDate, currentDate)) {
                    // Move current event to next working day
                    const adjustedDate = addWorkingDays(formatDateForCalc(prevDate), 1);
                    period[currentEvent.type] = adjustedDate;
                    currentEvent.date = adjustedDate;
                    console.log(`Adjusted ${currentEvent.type} to ${adjustedDate} to avoid same-day overlap with ${prevEvent.type}`);
                }
            }
        }


        function calculateDatesForPeriod(period) {
            // Ensure period.rosterStart is a valid Date object
            if (!period.rosterStart || !(period.rosterStart instanceof Date) || isNaN(period.rosterStart.getTime())) {
                console.error("calculateDatesForPeriod: Invalid or missing period.rosterStart", JSON.parse(JSON.stringify(period)));
                return;
            }

            const rosterStart = period.rosterStart;

            // --- Existing Event Calculations ---
            
            // Calculate SP Cutoff (M-2)
            const spCutoffDate = new Date(rosterStart);
            spCutoffDate.setUTCMonth(spCutoffDate.getUTCMonth() - appSettings.spCutoffRule.monthsPrior);
            spCutoffDate.setUTCDate(appSettings.spCutoffRule.day);
            period.spCutoff = normalizeToUTCMidnight(adjustForWeekend(spCutoffDate, appSettings.spCutoffRule.weekendAdjustment));

            // Calculate SP Feedback
            period.spFeedback = normalizeToUTCMidnight(addWorkingDays(formatDateForCalc(period.spCutoff), appSettings.spFeedbackOffset));

            // Calculate Trade Off Discussion
            period.tradeOffDiscussion = normalizeToUTCMidnight(addWorkingDays(formatDateForCalc(period.spFeedback), appSettings.tradeOffOffset));

            // Calculate SSIM Handover
            period.finalSSIMHandover = normalizeToUTCMidnight(addWorkingDays(formatDateForCalc(period.tradeOffDiscussion), appSettings.ssimHandoverOffset));

            // If SSIM Handover is Friday and the rule is enabled, move to Thursday
            if (appSettings.ssimFridayRule && period.finalSSIMHandover.getUTCDay() === FRIDAY) {
                let prevDay = new Date(period.finalSSIMHandover.getTime());
                prevDay.setUTCDate(prevDay.getUTCDate() - 1);
                period.finalSSIMHandover = getFinalAdjustedDate(formatDateForCalc(prevDay));
            }

            // Calculate Publish Dates (from end of month prior to rosterStart)
            const eomPriorRoster = getEOMPriorRoster(formatDateForCalc(rosterStart));
            if (!eomPriorRoster) {
                console.error("calculateDatesForPeriod: Could not determine EOM Prior Roster from period data.", JSON.parse(JSON.stringify(period)));
                return;
            }
            
            const baseTechCrewPublishDate = new Date(eomPriorRoster.getTime());
            baseTechCrewPublishDate.setUTCDate(baseTechCrewPublishDate.getUTCDate() - appSettings.techCrewPublishOffset);
            period.techCrewPublish = getFinalAdjustedDate(formatDateForCalc(baseTechCrewPublishDate));
            
            // Calculate Cabin Crew Publish date (if not already set)
            if (!period.cabinCrewPublish && appSettings.cabinCrewPublishOffset !== undefined) {
                const baseCabinCrewPublishDate = new Date(eomPriorRoster.getTime());
                baseCabinCrewPublishDate.setUTCDate(baseCabinCrewPublishDate.getUTCDate() - appSettings.cabinCrewPublishOffset);
                period.cabinCrewPublish = getFinalAdjustedDate(formatDateForCalc(baseCabinCrewPublishDate));
            }

            // --- New Event Type Calculations ---
            
            // 1. Training Handover (Tech & Cabin) - calendar days from Final SSIM Handover
            if (appSettings.trainingHandoverOffset !== undefined && period.finalSSIMHandover) {
                const trainingHandoverDate = new Date(period.finalSSIMHandover.getTime());
                trainingHandoverDate.setUTCDate(trainingHandoverDate.getUTCDate() + appSettings.trainingHandoverOffset);
                period.trainingHandoverTech = normalizeToUTCMidnight(trainingHandoverDate);
                period.trainingHandoverCabin = normalizeToUTCMidnight(new Date(trainingHandoverDate.getTime()));
                
                // Validate the date objects
                if (!(period.trainingHandoverTech instanceof Date) || isNaN(period.trainingHandoverTech.getTime())) {
                    console.error(`calculateDatesForPeriod: Invalid trainingHandoverTech date calculated for ${period.bidPeriodName}:`, period.trainingHandoverTech);
                    period.trainingHandoverTech = new Date(period.finalSSIMHandover); // Fallback to a safe date
                }
                
                if (!(period.trainingHandoverCabin instanceof Date) || isNaN(period.trainingHandoverCabin.getTime())) {
                    console.error(`calculateDatesForPeriod: Invalid trainingHandoverCabin date calculated for ${period.bidPeriodName}:`, period.trainingHandoverCabin);
                    period.trainingHandoverCabin = new Date(period.finalSSIMHandover); // Fallback to a safe date
                }
            }
            
            // 2. Roster Build Commence (Tech) - calendar days from Tech Crew Publish
            if (appSettings.rosterBuildCommenceTechOffset !== undefined && period.techCrewPublish) {
                const rosterBuildCommenceTech = new Date(period.techCrewPublish.getTime());
                rosterBuildCommenceTech.setUTCDate(rosterBuildCommenceTech.getUTCDate() + appSettings.rosterBuildCommenceTechOffset);
                period.rosterBuildCommenceTech = normalizeToUTCMidnight(rosterBuildCommenceTech);
                
                // Validate the date object
                if (!(period.rosterBuildCommenceTech instanceof Date) || isNaN(period.rosterBuildCommenceTech.getTime())) {
                    console.error(`calculateDatesForPeriod: Invalid rosterBuildCommenceTech date calculated for ${period.bidPeriodName}:`, period.rosterBuildCommenceTech);
                    period.rosterBuildCommenceTech = new Date(period.techCrewPublish); // Fallback to a safe date
                }
            }
            
            // 3. Roster Build Commence (Cabin) - calendar days from Cabin Crew Publish
            if (appSettings.rosterBuildCommenceCabinOffset !== undefined && period.cabinCrewPublish) {
                const rosterBuildCommenceCabin = new Date(period.cabinCrewPublish.getTime());
                rosterBuildCommenceCabin.setUTCDate(rosterBuildCommenceCabin.getUTCDate() + appSettings.rosterBuildCommenceCabinOffset);
                period.rosterBuildCommenceCabin = normalizeToUTCMidnight(rosterBuildCommenceCabin);
                
                // Validate the date object
                if (!(period.rosterBuildCommenceCabin instanceof Date) || isNaN(period.rosterBuildCommenceCabin.getTime())) {
                    console.error(`calculateDatesForPeriod: Invalid rosterBuildCommenceCabin date calculated for ${period.bidPeriodName}:`, period.rosterBuildCommenceCabin);
                    period.rosterBuildCommenceCabin = new Date(period.cabinCrewPublish); // Fallback to a safe date
                }
            }
            
            // 4. Bidding Closure (Tech) - calendar days from Roster Build Commence Tech
            if (appSettings.biddingClosureTechOffset !== undefined && period.rosterBuildCommenceTech) {
                const biddingClosureTech = new Date(period.rosterBuildCommenceTech.getTime());
                biddingClosureTech.setUTCDate(biddingClosureTech.getUTCDate() + appSettings.biddingClosureTechOffset);
                period.biddingClosureTech = normalizeToUTCMidnight(biddingClosureTech);
                
                // Validate the date object
                if (!(period.biddingClosureTech instanceof Date) || isNaN(period.biddingClosureTech.getTime())) {
                    console.error(`calculateDatesForPeriod: Invalid biddingClosureTech date calculated for ${period.bidPeriodName}:`, period.biddingClosureTech);
                    period.biddingClosureTech = new Date(period.rosterBuildCommenceTech); // Fallback to a safe date
                }
            }
            
            // 5. Bidding Closure (Cabin) - calendar days from Roster Build Commence Cabin
            if (appSettings.biddingClosureCabinOffset !== undefined && period.rosterBuildCommenceCabin) {
                const biddingClosureCabin = new Date(period.rosterBuildCommenceCabin.getTime());
                biddingClosureCabin.setUTCDate(biddingClosureCabin.getUTCDate() + appSettings.biddingClosureCabinOffset);
                period.biddingClosureCabin = normalizeToUTCMidnight(biddingClosureCabin);
                
                // Validate the date object
                if (!(period.biddingClosureCabin instanceof Date) || isNaN(period.biddingClosureCabin.getTime())) {
                    console.error(`calculateDatesForPeriod: Invalid biddingClosureCabin date calculated for ${period.bidPeriodName}:`, period.biddingClosureCabin);
                    period.biddingClosureCabin = new Date(period.rosterBuildCommenceCabin); // Fallback to a safe date
                }
            }
            
            // 6. CB Pairing Publish (Tech) - working days from Bidding Closure Tech
            if (appSettings.cbPairingPublishTechOffset !== undefined && period.biddingClosureTech) {
                period.cbPairingPublishTech = normalizeToUTCMidnight(
                    addWorkingDays(formatDateForCalc(period.biddingClosureTech), appSettings.cbPairingPublishTechOffset)
                );
                
                // Validate the date object
                if (!(period.cbPairingPublishTech instanceof Date) || isNaN(period.cbPairingPublishTech.getTime())) {
                    console.error(`calculateDatesForPeriod: Invalid cbPairingPublishTech date calculated for ${period.bidPeriodName}:`, period.cbPairingPublishTech);
                    period.cbPairingPublishTech = new Date(period.biddingClosureTech); // Fallback to a safe date
                }
            }
            
            // 7. CB Pairing Publish (Cabin) - working days from Bidding Closure Cabin
            if (appSettings.cbPairingPublishCabinOffset !== undefined && period.biddingClosureCabin) {
                period.cbPairingPublishCabin = normalizeToUTCMidnight(
                    addWorkingDays(formatDateForCalc(period.biddingClosureCabin), appSettings.cbPairingPublishCabinOffset)
                );
                
                // Validate the date object
                if (!(period.cbPairingPublishCabin instanceof Date) || isNaN(period.cbPairingPublishCabin.getTime())) {
                    console.error(`calculateDatesForPeriod: Invalid cbPairingPublishCabin date calculated for ${period.bidPeriodName}:`, period.cbPairingPublishCabin);
                    period.cbPairingPublishCabin = new Date(period.biddingClosureCabin); // Fallback to a safe date
                }
            }

            // Apply No Overlap Rule if enabled
            if (appSettings.enableNoOverlapRule) {
                applyNoOverlapRule(period);
            }
        }


        function adjustForWeekend(date, adjustment) {
            const day = date.getDay();
            if (day === 0 || day === 6) { // Weekend
                switch (adjustment) {
                    case 'nextWorkingDay':
                        while (date.getDay() === 0 || date.getDay() === 6 || isPublicHoliday(date)) {
                            date.setDate(date.getDate() + 1);
                        }
                        break;
                    case 'previousWorkingDay':
                        while (date.getDay() === 0 || date.getDay() === 6 || isPublicHoliday(date)) {
                            date.setDate(date.getDate() - 1);
                        }
                        break;
                }
            }
            return date;
        }

        function createNewBidPeriod(bidPeriodName, rosterStartDate, rosterEndDate, isStatic = false) {
            return {
                id: generateBidPeriodId(),
                bidPeriodName: bidPeriodName,
                rosterStart: normalizeToUTCMidnight(rosterStartDate),
                rosterEnd: normalizeToUTCMidnight(rosterEndDate),
                // Original event types
                spCutoff: null,
                spFeedback: null,
                tradeOffDiscussion: null,
                finalSSIMHandover: null,
                techCrewPublish: null,
                cabinCrewPublish: null,
                // New event types
                trainingHandoverTech: null,
                trainingHandoverCabin: null,
                rosterBuildCommenceTech: null,
                rosterBuildCommenceCabin: null,
                biddingClosureTech: null,
                biddingClosureCabin: null,
                cbPairingPublishTech: null,
                cbPairingPublishCabin: null,
                // Other properties
                affectedHolidays: [],
                approvalStatus: isStatic ? "Approved" : "Pending", // Set approval status
                isStaticOrigin: isStatic // Mark if it's from static data
            };
        }

        function initializeDefaultPeriods() {
            console.log('DEBUG: initializeDefaultPeriods - Loading static reference data into allBidPeriodData.');

            if (!staticReferenceDataSource || staticReferenceDataSource.length === 0) {
                console.warn("DEBUG: initializeDefaultPeriods - staticReferenceDataSource is empty. No static periods will be added.");
                return;
            }

            staticReferenceDataSource.forEach(staticItem => {
                const bidPeriodName = staticItem.bid;
                // Attempt to parse year and month from bidPeriodName (e.g., "Oct-25")
                const nameParts = bidPeriodName.match(/^([a-zA-Z]{3})-?(\d{2}|\d{4})$/);
                if (!nameParts || nameParts.length < 3) {
                    console.error(`DEBUG: initializeDefaultPeriods - Could not parse bid period name: ${bidPeriodName} from static data.`);
                    return; // Skip this item
                }
                const monthKey = nameParts[1];
                const yearSuffix = nameParts[2];
                const year = parseInt(yearSuffix.length === 2 ? "20" + yearSuffix : yearSuffix);

                const standardDates = getStandardRosterDates(monthKey, year);
                if (!standardDates || !standardDates.startDateStr || !standardDates.endDateStr) {
                    console.error(`DEBUG: initializeDefaultPeriods - Could not get standard roster dates for ${bidPeriodName}`);
                    return; // Skip this item
                }
                
                const rosterStartDate = parseDate(standardDates.startDateStr);
                const rosterEndDate = parseDate(standardDates.endDateStr);

                if (!rosterStartDate || !rosterEndDate) {
                    console.error(`DEBUG: initializeDefaultPeriods - Could not parse roster dates for ${bidPeriodName}`);
                    return; // Skip this item
                }

                // Create a new period object, marking it as static origin
                const period = createNewBidPeriod(bidPeriodName, rosterStartDate, rosterEndDate, true); // true for isStatic

                // Populate dates from staticItem, overriding calculated ones if necessary
                // For static items, we trust the provided dates more than recalculating all.
                // However, calculateDatesForPeriod will still run to fill in any missing ones based on SP Cutoff.
                // We need to ensure spCutoff is set from staticItem if available.
                
                // Manually set dates from staticItem if they exist
                period.spCutoff = staticItem.spc ? parseDisplayDate(staticItem.spc) : period.spCutoff;
                period.spFeedback = staticItem.spf ? parseDisplayDate(staticItem.spf) : period.spFeedback;
                period.tradeOffDiscussion = staticItem.tod ? parseDisplayDate(staticItem.tod) : period.tradeOffDiscussion;
                period.finalSSIMHandover = staticItem.ssim ? parseDisplayDate(staticItem.ssim) : period.finalSSIMHandover;
                period.techCrewPublish = staticItem.tcp ? parseDisplayDate(staticItem.tcp) : period.techCrewPublish;
                period.cabinCrewPublish = staticItem.ccp ? parseDisplayDate(staticItem.ccp) : period.cabinCrewPublish;
                
                // If spCutoff was not in staticItem, calculateDatesForPeriod will use its default logic.
                // If it was, calculateDatesForPeriod will use that as the base.
                // This ensures all dates are populated.
                if (!period.spCutoff) { // If SP Cutoff is still null, it means it wasn't in staticItem. Calculate it.
                    calculateDatesForPeriod(period); // This will calculate SP Cutoff and then others.
                } else {
                    // If SP Cutoff *was* provided, we still might want to ensure other dates are calculated *from it* if they were missing.
                    // The calculateDatesForPeriod function is designed to work from an existing spCutoff if present.
                    calculateDatesForPeriod(period);
                }


                console.log('DEBUG: initializeDefaultPeriods - Processed static item:', JSON.parse(JSON.stringify(period)));
                allBidPeriodData.push(period);
            });

            // After adding all static periods, sort the array
            allBidPeriodData.sort((a, b) => {
                if (!a.rosterStart || !b.rosterStart) return 0; // Handle cases where rosterStart might be null
                return a.rosterStart.getTime() - b.rosterStart.getTime();
            });
            console.log('DEBUG: initializeDefaultPeriods - allBidPeriodData after loading static items and sorting:', JSON.parse(JSON.stringify(allBidPeriodData)));
        }

        // Color presets
        const colorPresets = [
            { name: 'Light Blue', value: '#e0f2fe' },
            { name: 'Light Yellow', value: '#fef9c3' },
            { name: 'Light Green', value: '#dcfce7' },
            { name: 'Light Purple', value: '#f3e8ff' },
            { name: 'Light Pink', value: '#fce7f3' },
            { name: 'Light Orange', value: '#ffedd5' },
            { name: 'Light Teal', value: '#ccfbf1' },
            { name: 'Light Red', value: '#fee2e2' },
            { name: 'Light Indigo', value: '#e0e7ff' },
            { name: 'Light Gray', value: '#f3f4f6' }
        ];

        // Tab System
        function switchTab(tabId) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
                content.style.display = 'none';
            });
            
            // Show selected tab content
            const selectedTab = document.getElementById(tabId);
            selectedTab.classList.add('active');
            selectedTab.style.display = 'block';
            
            // Update tab button states
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Find and activate the clicked tab button
            const activeButton = Array.from(document.querySelectorAll('.tab-button')).find(
                button => button.getAttribute('onclick').includes(tabId)
            );
            if (activeButton) activeButton.classList.add('active');

            // Ensure Roster Definitions table is populated when its tab is selected
            if (tabId === 'rosterDefinitions') {
                populateRosterPeriodsReference(rosterReferenceCurrentYear);
            }
            // Ensure tooltips for header names are initialized when calendar tab is shown
            if (tabId === 'calendar') {
                initializeHeaderNameTooltips();
            }
        }

        function createColorPresets(containerId, selectedColor) {
            const container = document.getElementById(containerId);
            container.style.width = '100%'; // Update container width
            container.innerHTML = '';
            
            colorPresets.forEach(preset => {
                const div = document.createElement('div');
                div.className = `color-preset${preset.value === selectedColor ? ' selected' : ''}`;
                div.style.backgroundColor = preset.value;
                div.setAttribute('data-color', preset.value);
                div.setAttribute('title', preset.name);
                div.onclick = () => selectColor(containerId, preset.value);
                container.appendChild(div);
            });
        }

        function selectColor(containerId, color) {
            const container = document.getElementById(containerId);
            container.querySelectorAll('.color-preset').forEach(preset => {
                preset.classList.remove('selected');
                if (preset.getAttribute('data-color') === color) {
                    preset.classList.add('selected');
                }
            });
            
            // Update the corresponding setting
            const type = containerId.replace('ColorPresets', '');
            appSettings.colors = appSettings.colors || {};
            appSettings.colors[type] = color;
        }

        function getDisplayHeader(key, defaultText, date) {
            const monthName = date.toLocaleString('default', { month: 'short' });
            const customText = appSettings.headerDisplayNames?.[key] || defaultText;
            return `${customText} (${monthName})`;
        }

        function getCustomColor(type, defaultColor) {
            return appSettings.colors?.[type] || defaultColor;
        }

        function updateCalendarGrid() {
            const container = document.querySelector('.calendar-grid-container');
            if (!container) return;

            const headers = container.querySelectorAll('.calendar-grid-header');
            headers.forEach(header => {
                const type = header.getAttribute('data-type');
                if (!type) return;

                const date = new Date(header.getAttribute('data-date'));
                if (isNaN(date.getTime())) return;

                switch (type) {
                    case 'spCutoff':
                        header.textContent = getDisplayHeader('spCutoff', 'SP CUTOFF', date);
                        break;
                    case 'crewBid':
                        header.textContent = getDisplayHeader('crewBid', 'CREW BID', date);
                        break;
                    // Add other header types as needed
                }
            });

            const cells = container.querySelectorAll('.calendar-grid-day-cell');
            cells.forEach(cell => {
                const type = cell.getAttribute('data-type');
                if (!type) return;

                switch (type) {
                    case 'planning':
                        cell.style.backgroundColor = getCustomColor('planning', '#e0f2fe');
                        break;
                    case 'publish':
                        cell.style.backgroundColor = getCustomColor('publish', '#fef9c3');
                        break;
                    case 'holiday':
                        cell.style.backgroundColor = getCustomColor('holiday', '#f3f4f6');
                        break;
                }
            });
        }

        function loadInitialData() {
            console.log('DEBUG: loadInitialData called. Current allBidPeriodData before load:', JSON.parse(JSON.stringify(allBidPeriodData)));
            const storedData = localStorage.getItem('bidPeriodData');
            if (storedData) {
                console.log('DEBUG: loadInitialData - Found data in localStorage. Parsing...');
                try {
                    const parsedData = JSON.parse(storedData);
                    console.log('DEBUG: loadInitialData - Parsed localStorage data:', JSON.parse(JSON.stringify(parsedData)));
                    allBidPeriodData = parsedData.map(period => ({
                        ...period,
                        // Ensure date objects are created, and handle potential old 'startDate'/'endDate'
                        rosterStart: period.rosterStart ? new Date(period.rosterStart) : (period.startDate ? new Date(period.startDate) : null),
                        rosterEnd: period.rosterEnd ? new Date(period.rosterEnd) : (period.endDate ? new Date(period.endDate) : null),
                        // Original event types
                        spCutoff: period.spCutoff ? new Date(period.spCutoff) : null,
                        spFeedback: period.spFeedback ? new Date(period.spFeedback) : null,
                        tradeOffDiscussion: period.tradeOffDiscussion ? new Date(period.tradeOffDiscussion) : null,
                        finalSSIMHandover: period.finalSSIMHandover ? new Date(period.finalSSIMHandover) : null,
                        techCrewPublish: period.techCrewPublish ? new Date(period.techCrewPublish) : null,
                        cabinCrewPublish: period.cabinCrewPublish ? new Date(period.cabinCrewPublish) : null,
                        // New event types from Phase 2
                        trainingHandoverTech: period.trainingHandoverTech ? new Date(period.trainingHandoverTech) : null,
                        trainingHandoverCabin: period.trainingHandoverCabin ? new Date(period.trainingHandoverCabin) : null,
                        rosterBuildCommenceTech: period.rosterBuildCommenceTech ? new Date(period.rosterBuildCommenceTech) : null,
                        rosterBuildCommenceCabin: period.rosterBuildCommenceCabin ? new Date(period.rosterBuildCommenceCabin) : null,
                        biddingClosureTech: period.biddingClosureTech ? new Date(period.biddingClosureTech) : null,
                        biddingClosureCabin: period.biddingClosureCabin ? new Date(period.biddingClosureCabin) : null,
                        cbPairingPublishTech: period.cbPairingPublishTech ? new Date(period.cbPairingPublishTech) : null,
                        cbPairingPublishCabin: period.cbPairingPublishCabin ? new Date(period.cbPairingPublishCabin) : null,
                        // Other properties
                        approvalStatus: period.approvalStatus || "Pending", // Load approval status, default to Pending
                        isStaticOrigin: period.isStaticOrigin || false // Load isStaticOrigin, default to false
                    }));
                    console.log('DEBUG: loadInitialData - Mapped allBidPeriodData from localStorage:', JSON.parse(JSON.stringify(allBidPeriodData)));
                } catch (e) {
                    console.error('Error loading saved data:', e);
                    showToast('Error loading saved data. Initializing with defaults.', 3000);
                    allBidPeriodData = []; // Clear any partially loaded data
                    initializeDefaultPeriods(); // Load static data as a fallback
                    saveBidPeriodData(); // Save the newly initialized default data
                }
            } else {
                console.log('DEBUG: loadInitialData - No data in localStorage, calling initializeDefaultPeriods to load static data.');
                allBidPeriodData = []; // Ensure it's empty before loading defaults
                initializeDefaultPeriods(); // Load static data
                saveBidPeriodData(); // Save the newly initialized default data
            }

        // Ensure allBidPeriodData is sorted after loading from localStorage or defaults
        allBidPeriodData.sort((a, b) => {
                if (!a.rosterStart || !b.rosterStart) return 0;
                return a.rosterStart.getTime() - b.rosterStart.getTime();
            });

            // Ensure all event types are calculated for all periods
            allBidPeriodData.forEach(period => {
                if (period.finalSSIMHandover) {
                    // Force recalculation of all events that might be missing
                    if (!period.trainingHandoverTech || !period.trainingHandoverCabin) {
                        console.log(`Recalculating missing Training Handover events for ${period.bidPeriodName}`);
                        // Training Handover calculation
                        const trainingHandoverDate = new Date(period.finalSSIMHandover.getTime());
                        trainingHandoverDate.setUTCDate(trainingHandoverDate.getUTCDate() + appSettings.trainingHandoverOffset);
                        period.trainingHandoverTech = normalizeToUTCMidnight(trainingHandoverDate);
                        period.trainingHandoverCabin = normalizeToUTCMidnight(new Date(trainingHandoverDate.getTime()));
                    }
                }
                
                if (period.techCrewPublish) {
                    // Force recalculation of Tech roster build if missing
                    if (!period.rosterBuildCommenceTech) {
                        console.log(`Recalculating missing Roster Build Tech event for ${period.bidPeriodName}`);
                        const rosterBuildCommenceTech = new Date(period.techCrewPublish.getTime());
                        rosterBuildCommenceTech.setUTCDate(rosterBuildCommenceTech.getUTCDate() + appSettings.rosterBuildCommenceTechOffset);
                        period.rosterBuildCommenceTech = normalizeToUTCMidnight(rosterBuildCommenceTech);
                    }
                    
                    // Recalculate bidding closure events if missing
                    if (period.rosterBuildCommenceTech && !period.biddingClosureTech) {
                        console.log(`Recalculating missing Bidding Closure Tech event for ${period.bidPeriodName}`);
                        const biddingClosureTech = new Date(period.rosterBuildCommenceTech.getTime());
                        biddingClosureTech.setUTCDate(biddingClosureTech.getUTCDate() + appSettings.biddingClosureTechOffset);
                        period.biddingClosureTech = normalizeToUTCMidnight(biddingClosureTech);
                    }
                    
                    // Recalculate CB pairing events if missing
                    if (period.biddingClosureTech && !period.cbPairingPublishTech) {
                        console.log(`Recalculating missing CB Pairing Publish Tech event for ${period.bidPeriodName}`);
                        const cbPairingPublishTech = new Date(period.biddingClosureTech.getTime());
                        cbPairingPublishTech.setUTCDate(cbPairingPublishTech.getUTCDate() + appSettings.cbPairingPublishTechOffset);
                        period.cbPairingPublishTech = normalizeToUTCMidnight(cbPairingPublishTech);
                    }
                }
            });
            
            // Save the corrected data
            saveBidPeriodData();
            
            // Debug logging
            debugCheckAllEvents();
            
            // renderResultsTable(); // Called after ssim pagination is initialized
            renderCalendarView(); // Ensure calendar is rendered with loaded data
            updateCalendarGrid(); // Update styles/text on the now-rendered calendar
            updateEmptyStateMessages();
            initializeSsimTablePagination(); // Initialize SSIM table view settings
            renderResultsTable(); // Now render SSIM table with correct view
        }

        // Temporary debug function to check all events in periods
        function debugCheckAllEvents() {
            console.log('===== DEBUGGING EVENT DATES =====');
            allBidPeriodData.forEach((period, idx) => {
                console.log(`Period ${idx}: ${period.bidPeriodName}`);
                console.log('  Tech Events:');
                console.log('     trainingHandoverTech:', period.trainingHandoverTech);
                console.log('     rosterBuildCommenceTech:', period.rosterBuildCommenceTech);  
                console.log('     biddingClosureTech:', period.biddingClosureTech);
                console.log('     cbPairingPublishTech:', period.cbPairingPublishTech);
                console.log('  Cabin Events:');
                console.log('     trainingHandoverCabin:', period.trainingHandoverCabin);
                console.log('     rosterBuildCommenceCabin:', period.rosterBuildCommenceCabin);
                console.log('     biddingClosureCabin:', period.biddingClosureCabin);
                console.log('     cbPairingPublishCabin:', period.cbPairingPublishCabin);
            });
            
            // Check visibility settings
            console.log('===== VISIBILITY SETTINGS =====');
            console.log(JSON.stringify(appSettings.eventTypeVisibility, null, 2));
        }

        // Call this function at the end of loadInitialData
        // Removed redundant saveBidPeriodData function here as it's defined earlier

        // --- Auto-Approve Past Periods ---
        // Sets any past period with "Pending" status to "Approved"
        function autoApprovePastPeriods() {
            const today = new Date();
            today.setUTCHours(0, 0, 0, 0);
            let approvedCount = 0;

            allBidPeriodData.forEach(period => {
                if (period.rosterStart && period.rosterStart < today) {
                    if (period.approvalStatus === 'Pending' || !period.approvalStatus) {
                        period.approvalStatus = 'Approved';
                        approvedCount++;
                        console.log(`AUTO-APPROVE: Set ${period.bidPeriodName} to Approved (past period)`);
                    }
                }
            });

            if (approvedCount > 0) {
                console.log(`AUTO-APPROVE: Auto-approved ${approvedCount} past period(s)`);
                saveBidPeriodData();
            }
            return approvedCount;
        }

        // --- Auto-Generate Missing Future Periods ---
        // Generates missing periods from current month to X months ahead
        function autoGenerateMissingPeriods() {
            if (!appSettings.autoGenerateEnabled) {
                console.log('AUTO-GENERATE: Disabled in settings');
                return 0;
            }

            const today = new Date();
            const currentMonth = today.getUTCMonth();
            const currentYear = today.getUTCFullYear();
            const monthsAhead = appSettings.autoGenerateMonthsAhead || 18;

            let generatedCount = 0;
            const monthAbbreviations = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            console.log(`AUTO-GENERATE: Checking periods from ${monthAbbreviations[currentMonth]}-${currentYear} to +${monthsAhead} months`);

            for (let i = 0; i < monthsAhead; i++) {
                const targetDate = new Date(Date.UTC(currentYear, currentMonth + i, 1));
                const targetMonth = targetDate.getUTCMonth();
                const targetYear = targetDate.getUTCFullYear();
                const periodName = `${monthAbbreviations[targetMonth]}-${String(targetYear).slice(-2)}`;

                // Check if period already exists
                const exists = allBidPeriodData.some(p =>
                    p.bidPeriodName && p.bidPeriodName.toLowerCase() === periodName.toLowerCase()
                );

                if (!exists) {
                    console.log(`AUTO-GENERATE: Creating missing period ${periodName}`);
                    const created = createPeriodFromDefinition(periodName, targetMonth, targetYear);
                    if (created) {
                        generatedCount++;
                    }
                }
            }

            if (generatedCount > 0) {
                // Sort after adding
                allBidPeriodData.sort((a, b) => {
                    if (!a.rosterStart || !b.rosterStart) return 0;
                    return a.rosterStart.getTime() - b.rosterStart.getTime();
                });
                saveBidPeriodData();
                console.log(`AUTO-GENERATE: Created ${generatedCount} new period(s)`);
            }

            return generatedCount;
        }

        // Helper function to create a period from standardRosterPeriodDefinitions
        function createPeriodFromDefinition(periodName, monthIndex, year) {
            const monthAbbreviations = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const monthAbbr = monthAbbreviations[monthIndex];

            const definition = standardRosterPeriodDefinitions.find(
                def => def.period.toLowerCase() === monthAbbr.toLowerCase()
            );

            if (!definition) {
                console.error(`AUTO-GENERATE: No definition found for ${monthAbbr}`);
                return false;
            }

            try {
                const rosterStartStr = definition.startRule(year);
                const rosterEndStr = definition.endRule(year);
                const rosterStart = parseDate(rosterStartStr);
                const rosterEnd = parseDate(rosterEndStr);

                if (!rosterStart || !rosterEnd) {
                    console.error(`AUTO-GENERATE: Invalid dates for ${periodName}`);
                    return false;
                }

                // Calculate SP Cutoff using the standard rule
                const spCutoffDate = new Date(rosterStart);
                spCutoffDate.setUTCMonth(spCutoffDate.getUTCMonth() - appSettings.spCutoffRule.monthsPrior);
                spCutoffDate.setUTCDate(appSettings.spCutoffRule.day);
                const adjustedSpCutoff = adjustForWeekend(spCutoffDate, appSettings.spCutoffRule.weekendAdjustment);

                // Calculate other dates
                const spFeedbackDate = addWorkingDays(formatDateForCalc(adjustedSpCutoff), appSettings.spFeedbackOffset);
                const tradeOffDiscussionDate = addWorkingDays(formatDateForCalc(spFeedbackDate), appSettings.tradeOffOffset);
                let finalSSIMHandoverDate = addWorkingDays(formatDateForCalc(tradeOffDiscussionDate), appSettings.ssimHandoverOffset);

                if (appSettings.ssimFridayRule && finalSSIMHandoverDate.getUTCDay() === FRIDAY) {
                    let prevDay = new Date(finalSSIMHandoverDate.getTime());
                    prevDay.setUTCDate(prevDay.getUTCDate() - 1);
                    finalSSIMHandoverDate = getFinalAdjustedDate(formatDateForCalc(prevDay));
                }

                // Calculate publish dates
                const baseTechCrewPublishDate = new Date(rosterStart.getTime());
                baseTechCrewPublishDate.setUTCDate(baseTechCrewPublishDate.getUTCDate() - (appSettings.techCrewPublishOffset + 1));
                const finalTechCrewPublishDate = getFinalAdjustedDate(formatDateForCalc(baseTechCrewPublishDate));

                const baseCabinCrewPublishDate = new Date(rosterStart.getTime());
                baseCabinCrewPublishDate.setUTCDate(baseCabinCrewPublishDate.getUTCDate() - (appSettings.cabinCrewPublishOffset + 1));
                const finalCabinCrewPublishDate = getFinalAdjustedDate(formatDateForCalc(baseCabinCrewPublishDate));

                // Create the period object
                const newPeriod = {
                    id: 'auto_' + Date.now() + '_' + periodName.replace(/\s/g, '_'),
                    bidPeriodName: periodName,
                    rosterStart: normalizeToUTCMidnight(rosterStart),
                    rosterEnd: normalizeToUTCMidnight(rosterEnd),
                    spCutoff: normalizeToUTCMidnight(adjustedSpCutoff),
                    spFeedback: spFeedbackDate,
                    tradeOffDiscussion: tradeOffDiscussionDate,
                    finalSSIMHandover: finalSSIMHandoverDate,
                    techCrewPublish: finalTechCrewPublishDate,
                    cabinCrewPublish: finalCabinCrewPublishDate,
                    approvalStatus: 'Pending',
                    isStaticOrigin: false,
                    autoGenerated: true,
                    affectedHolidays: []
                };

                allBidPeriodData.push(newPeriod);
                return true;

            } catch (error) {
                console.error(`AUTO-GENERATE: Error creating ${periodName}:`, error);
                return false;
            }
        }

        // --- Generate All Periods for a Year ---
        function generatePeriodsForYear(year) {
            const monthAbbreviations = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            let generatedCount = 0;
            let skippedCount = 0;

            for (let month = 0; month < 12; month++) {
                const periodName = `${monthAbbreviations[month]}-${String(year).slice(-2)}`;

                // Check if period already exists
                const exists = allBidPeriodData.some(p =>
                    p.bidPeriodName && p.bidPeriodName.toLowerCase() === periodName.toLowerCase()
                );

                if (exists) {
                    skippedCount++;
                    continue;
                }

                const created = createPeriodFromDefinition(periodName, month, year);
                if (created) {
                    generatedCount++;
                }
            }

            if (generatedCount > 0) {
                // Sort and save
                allBidPeriodData.sort((a, b) => {
                    if (!a.rosterStart || !b.rosterStart) return 0;
                    return a.rosterStart.getTime() - b.rosterStart.getTime();
                });
                saveBidPeriodData();
                renderResultsTable();
                renderCalendarView();
            }

            showToast(`Generated ${generatedCount} period(s) for ${year}. ${skippedCount} already existed.`, 3000);
            return { generated: generatedCount, skipped: skippedCount };
        }

        function initialize() {
            console.log('DEBUG: initialize() called.');
            // Initialize color presets - DISABLED: Using HTML color pickers instead
            // createColorPresets('planningColorPresets', appSettings.colors?.planning || '#e0f2fe');
            // createColorPresets('publishColorPresets', appSettings.colors?.publish || '#fef9c3');
            // createColorPresets('holidayColorPresets', appSettings.colors?.holiday || '#f3f4f6');

            // Initialize header display names
            if (appSettings.headerDisplayNames) {
                Object.entries(appSettings.headerDisplayNames).forEach(([key, value]) => {
                    const input = document.getElementById(`${key}Display`);
                    if (input) input.value = value;
                });
            }

            initializeAppSettings();
            // Initialize calendarViewStartDate to always be (current real-world month - 1)
            const todayForCalendar = new Date();
            calendarViewStartDate = new Date(Date.UTC(todayForCalendar.getFullYear(), todayForCalendar.getMonth() - 1, 1));
            console.log('DEBUG: initialize - Calendar view starts based on current date -1m:', calendarViewStartDate);

            initializePublicHolidays();
            initializeEventFilterDropdown(); // Initialize the event filter dropdown
            // populateStaticReferenceTable(); // Removed as table is merged
            populateYearDropdown();
            populateBidMonthDropdown(new Date().getFullYear());
            loadInitialData(); // This populates allBidPeriodData

            // Auto-approve past periods and auto-generate missing future periods
            const approvedCount = autoApprovePastPeriods();
            const generatedCount = autoGenerateMissingPeriods();
            if (approvedCount > 0 || generatedCount > 0) {
                console.log(`AUTO: Approved ${approvedCount} past period(s), Generated ${generatedCount} future period(s)`);
                // Re-render the SSIM table to show newly generated periods
                renderResultsTable();
            }

            console.log('DEBUG: initialize - Calling suggestSpCutoffDate() with isInitializing = true.');
            suggestSpCutoffDate(true); // Pass true for initialization
            updateCalendarGrid(); // This should now use the new calendarViewStartDate via renderCalendarView
            populateCalendarLegend();
            // initializeCollapsibleStaticTable(); // Removed as static table is gone
            setTimeout(updateEmptyStateMessages, 100);

            // Set up event listeners
            const settingInputs = document.querySelectorAll('#settingsPage input, #settingsPage select');
            settingInputs.forEach(input => {
                input.addEventListener('change', updateRecalculationNotice);
                input.addEventListener('keyup', updateRecalculationNotice);
            });
            document.addEventListener('scroll', hideHolidayTooltip, true);

            // Calendar Navigation Event Listeners
            const prevMonthButton = document.getElementById('prevMonthBtn');
            if (prevMonthButton) {
                prevMonthButton.addEventListener('click', navigateCalendarPreviousMonth);
            }
            const nextMonthButton = document.getElementById('nextMonthBtn');
            if (nextMonthButton) {
                nextMonthButton.addEventListener('click', navigateCalendarNextMonth);
            }
        }

        // --- SSIM Table Pagination Logic ---
        let ssimTableViewStartDate;
        const ssimTableMonthsToDisplay = 12;

        function initializeSsimTablePagination() {
            console.log('DEBUG: initializeSsimTablePagination called.');
            const today = new Date();
            // Set initial view to start 5 months before the current real-world month,
            // creating a 12-month window where the current month is roughly in the middle.
            // (current month is month 0 in getUTCMonth(), so -5 means 5 months prior)
            ssimTableViewStartDate = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth() - 5, 1));

            console.log('DEBUG: initializeSsimTablePagination - Initial ssimTableViewStartDate set to:', ssimTableViewStartDate);
            // renderResultsTable() will be called by loadInitialData after this, or by navigation.
        }

        function updateSsimTableNavDisplay() {
            const displaySpan = document.getElementById('ssimTableDateRangeDisplay');
            const prevBtn = document.getElementById('ssimTablePrevMonthBtn');
            const nextBtn = document.getElementById('ssimTableNextMonthBtn');

            if (!displaySpan || !prevBtn || !nextBtn) return;

            if (allBidPeriodData.length === 0) {
                displaySpan.textContent = 'No data available';
                prevBtn.disabled = true;
                nextBtn.disabled = true;
                return;
            }

            // Find the earliest and latest dates in the *full* dataset
            const earliestDate = allBidPeriodData[0].rosterStart;
            const latestDate = allBidPeriodData[allBidPeriodData.length - 1].rosterStart;

            // Calculate the end date of the current view window
            const viewEndDate = new Date(ssimTableViewStartDate.getTime());
            viewEndDate.setUTCMonth(viewEndDate.getUTCMonth() + ssimTableMonthsToDisplay);
            viewEndDate.setUTCDate(0); // Go to the last day of the target month

            const startMonthYear = ssimTableViewStartDate.toLocaleString('default', { month: 'long', year: 'numeric', timeZone: 'UTC' });
            const endMonthYear = viewEndDate.toLocaleString('default', { month: 'long', year: 'numeric', timeZone: 'UTC' });

            displaySpan.textContent = `${startMonthYear} - ${endMonthYear}`;

            // Determine if there are periods before the current view start
            const hasPrevious = allBidPeriodData.some(period => {
                 if (!period.rosterStart || !(period.rosterStart instanceof Date) || isNaN(period.rosterStart.getTime())) return false;
                 return period.rosterStart.getTime() < ssimTableViewStartDate.getTime();
            });
            prevBtn.disabled = !hasPrevious;

            // Determine if there are periods after the current view end
             const hasNext = allBidPeriodData.some(period => {
                 if (!period.rosterStart || !(period.rosterStart instanceof Date) || isNaN(period.rosterStart.getTime())) return false;
                 return period.rosterStart.getTime() > viewEndDate.getTime();
            });
            nextBtn.disabled = !hasNext;
        }

        function navigateSsimTable(monthOffset) {
            console.log(`DEBUG: navigateSsimTable called with offset: ${monthOffset}`);
            if (!ssimTableViewStartDate) {
                 console.error("ssimTableViewStartDate is not initialized for navigation.");
                 return;
            }
            // Move the start date by the specified month offset
            ssimTableViewStartDate.setUTCMonth(ssimTableViewStartDate.getUTCMonth() + monthOffset);
            ssimTableViewStartDate.setUTCDate(1); // Ensure it's the first day of the new month
            console.log('DEBUG: navigateSsimTable - New ssimTableViewStartDate:', ssimTableViewStartDate);
            renderResultsTable(); // Re-render the table with the new date range
        }

        // Removed toggleStaticReferenceTable and initializeCollapsibleStaticTable as they are no longer used

        // --- CSV Export Logic ---
        function toggleExportSsimDropdown() {
            const dropdown = document.getElementById('exportSsimOptions');
            if (dropdown) {
                dropdown.classList.toggle('hidden');
            }
        }

        function exportSsimDataToCsv(scope) {
            console.log(`DEBUG: exportSsimDataToCsv called with scope: ${scope}`);
            let dataToExport = [];
            let filename = 'ssim_handover_dates';

            if (scope === 'viewable') {
                // Filter data based on the current view window, similar to renderResultsTable
                const viewEndDate = new Date(ssimTableViewStartDate.getTime());
                viewEndDate.setUTCMonth(viewEndDate.getUTCMonth() + ssimTableMonthsToDisplay);
                viewEndDate.setUTCDate(0); // Go to the last day of the target month

                dataToExport = allBidPeriodData.filter(period => {
                    if (!period.rosterStart || !(period.rosterStart instanceof Date) || isNaN(period.rosterStart.getTime())) return false;
                    return period.rosterStart.getTime() >= ssimTableViewStartDate.getTime() &&
                           period.rosterStart.getTime() <= viewEndDate.getTime();
                });
                const startMonthYear = ssimTableViewStartDate.toLocaleString('default', { month: 'short', year: 'numeric', timeZone: 'UTC' });
                const endMonthYear = viewEndDate.toLocaleString('default', { month: 'short', year: 'numeric', timeZone: 'UTC' });
                filename += `_${startMonthYear.replace(/\s/g, '')}_to_${endMonthYear.replace(/\s/g, '')}`;

            } else if (scope === 'all') {
                dataToExport = allBidPeriodData;
                filename += '_all_data';
            } else {
                console.error("Invalid export scope:", scope);
                showToast("Error: Invalid export scope.", 3000);
                return;
            }

            if (dataToExport.length === 0) {
                showToast("No data to export for the selected period.", 3000);
                return;
            }

            // Define CSV headers - ensure they match the data properties
            const headers = [
                "Bid Period", "SP Cutoff", "SP Feedback", "Trade Off Discussion",
                "Final SSIM Handover", "Tech Crew Publish", "Cabin Crew Publish", "Approval Status"
            ];

            // Map data objects to CSV rows
            const csvRows = dataToExport.map(period => {
                // Use formatDate for consistent date formatting in CSV
                return [
                    `"${period.bidPeriodName}"`, // Quote bid period name just in case
                    `"${formatDate(period.spCutoff)}"`,
                    `"${formatDate(period.spFeedback)}"`,
                    `"${formatDate(period.tradeOffDiscussion)}"`,
                    `"${formatDate(period.finalSSIMHandover)}"`,
                    `"${formatDate(period.techCrewPublish)}"`,
                    `"${formatDate(period.cabinCrewPublish)}"`,
                    `"${period.approvalStatus || 'Pending'}"` // Ensure status is included
                ].join(','); // Join columns with comma
            });

            // Combine headers and rows
            const csvContent = [
                headers.join(','), // Join headers with comma
                ...csvRows
            ].join('\n'); // Join rows with newline

            // Create a Blob and trigger download
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Feature detection for download attribute
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `${filename}.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                showToast("CSV exported successfully!", 2000);
            } else {
                // Fallback for browsers that don't support downloading files directly. Please copy the data manually.
                showToast("Your browser does not support downloading files directly. Please copy the data manually.", 4000);
                console.error("Download attribute not supported.");
            }

            toggleExportSsimDropdown(); // Hide dropdown after export
        }

        function navigateCalendarPreviousMonth() {
            if (calendarViewStartDate) {
                calendarViewStartDate.setUTCMonth(calendarViewStartDate.getUTCMonth() - 1);
                renderCalendarView();
            }
        }

        function navigateCalendarNextMonth() {
            if (calendarViewStartDate) {
                calendarViewStartDate.setUTCMonth(calendarViewStartDate.getUTCMonth() + 1);
                renderCalendarView();
            }
        }

        function applyCalendarZoomLevel(level) {
            if (level < 0 || level >= calendarZoomLevels.length) return;
            currentCalendarZoomLevel = level;

            const calendarGridContainer = document.getElementById('calendarGridContainer');
            const calendarGridWrapper = document.getElementById('calendarGridWrapper'); // Target for zoom classes

            if (!calendarGridContainer || !calendarGridWrapper) {
                console.error("Calendar grid container or wrapper not found for zoom.");
                return;
            }

            // Update grid column definition
            const zoomConfig = calendarZoomLevels[currentCalendarZoomLevel];
            // Ensure the first column (month name) uses minmax for flexibility
            calendarGridContainer.style.gridTemplateColumns = `minmax(4.5rem, max-content) repeat(31, minmax(${zoomConfig.dayColMin}, 1fr))`;

            // Update zoom class on the wrapper for font/style adjustments
            for (let i = 0; i < calendarZoomLevels.length; i++) {
                calendarGridWrapper.classList.remove(`calendar-zoom-${i}`);
            }
            calendarGridWrapper.classList.add(`calendar-zoom-${currentCalendarZoomLevel}`);

            localStorage.setItem(CALENDAR_ZOOM_STORAGE_KEY, currentCalendarZoomLevel);

            // Re-render might be needed if cell content changes drastically,
            // but for now, CSS handles font size and ellipsis.
            // If column width changes require re-layout of internal cell items beyond what CSS handles,
            // then a call to renderCalendarView() might be needed here.
            // For now, assuming CSS is sufficient for text changes.
            console.log(`DEBUG: Calendar zoom level ${currentCalendarZoomLevel} applied. Day col min: ${zoomConfig.dayColMin}`);

            // Update toggle switch state
            const zoomToggle = document.getElementById('calendarZoomToggle');
            if (zoomToggle) {
                // Level 0 (Standard) means toggle is UNCHECKED (visual left)
                // Level 1 (Compact) means toggle is CHECKED (visual right)
                zoomToggle.checked = (currentCalendarZoomLevel === 1);
            }
        }


        document.addEventListener('DOMContentLoaded', () => {
            // initializeSsimTablePagination(); // Moved to end of loadInitialData

            initialize();

            // Setup event listener for SSIM Handover date backward recalculation
            setupSSIMHandoverListener();

            // ESC key to close edit modal
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    const modalOverlay = document.getElementById('editModalOverlay');
                    if (modalOverlay && modalOverlay.classList.contains('active')) {
                        closeEditModal();
                    }
                }
            });

            // Add event listeners for SSIM Table Pagination buttons
            const ssimTablePrevMonthBtn = document.getElementById('ssimTablePrevMonthBtn');
            if (ssimTablePrevMonthBtn) {
                ssimTablePrevMonthBtn.addEventListener('click', () => navigateSsimTable(-1));
            }
            const ssimTableNextMonthBtn = document.getElementById('ssimTableNextMonthBtn');
            if (ssimTableNextMonthBtn) {
                ssimTableNextMonthBtn.addEventListener('click', () => navigateSsimTable(1));
            }

            // Add event listeners for CSV Export
            const exportSsimCsvBtn = document.getElementById('exportSsimCsvBtn');
            if (exportSsimCsvBtn) {
                exportSsimCsvBtn.addEventListener('click', toggleExportSsimDropdown);
            }

            const exportViewableCsv = document.getElementById('exportViewableCsv');
            if (exportViewableCsv) {
                exportViewableCsv.addEventListener('click', (e) => {
                    e.preventDefault(); // Prevent default link behavior
                    exportSsimDataToCsv('viewable');
                });
            }

            const exportAllCsv = document.getElementById('exportAllCsv');
            if (exportAllCsv) {
                exportAllCsv.addEventListener('click', (e) => {
                    e.preventDefault(); // Prevent default link behavior
                    exportSsimDataToCsv('all');
                });
            }

            // Close dropdown if clicking outside
            document.addEventListener('click', (event) => {
                const exportSsimOptions = document.getElementById('exportSsimOptions');
                const exportSsimCsvBtn = document.getElementById('exportSsimCsvBtn');
                if (exportSsimOptions && exportSsimCsvBtn && !exportSsimOptions.contains(event.target) && !exportSsimCsvBtn.contains(event.target)) {
                    exportSsimOptions.classList.add('hidden');
                }
            });

            // Add event listeners for Calendar Navigation buttons
            const prevMonthButton = document.getElementById('prevMonthBtn');
            if (prevMonthButton) {
                prevMonthButton.addEventListener('click', navigateCalendarPreviousMonth);
            }
            const nextMonthButton = document.getElementById('nextMonthBtn');
            if (nextMonthButton) {
                nextMonthButton.addEventListener('click', navigateCalendarNextMonth);
            }

            // Initialize zoom level from localStorage
            // Standard view (level 0) is default, so toggle should be unchecked.
            // Compact view (level 1) means toggle should be checked.
            const savedZoomLevel = localStorage.getItem(CALENDAR_ZOOM_STORAGE_KEY);
            const initialZoomLevel = (savedZoomLevel !== null) ? parseInt(savedZoomLevel, 10) : 0; // Default to 0 (Standard)
            applyCalendarZoomLevel(initialZoomLevel);
            // Ensure the toggle's visual state matches the initialZoomLevel
            const zoomToggle = document.getElementById('calendarZoomToggle');
            if (zoomToggle) {
                zoomToggle.checked = (initialZoomLevel === 1);

                // Event listener for the new zoom toggle switch
                zoomToggle.addEventListener('change', () => {
                    // If checked, user wants "Compact" (level 1)
                    // If unchecked, user wants "Standard" (level 0)
                    applyCalendarZoomLevel(zoomToggle.checked ? 1 : 0);
                });
            }

            // Event listener for the filter button
            const eventFilterBtn = document.getElementById('eventFilterBtn');
            const eventFilterDropdown = document.getElementById('eventFilterDropdown');
            if (eventFilterBtn && eventFilterDropdown) {
                eventFilterBtn.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent click from immediately closing if dropdown is part of body click listener
                    eventFilterDropdown.classList.toggle('hidden');
                });
                // Close dropdown if clicking outside
                document.addEventListener('click', (event) => {
                    if (!eventFilterDropdown.contains(event.target) && !eventFilterBtn.contains(event.target)) {
                        eventFilterDropdown.classList.add('hidden');
                    }
                });
            }
        });

        function initializeEventFilterDropdown() {
            const dropdownContainer = document.getElementById('eventFilterDropdown');
            if (!dropdownContainer) return;
            dropdownContainer.innerHTML = ''; // Clear any existing content
            dropdownContainer.className = 'absolute right-0 mt-2 w-60 bg-white rounded-md shadow-lg py-1 z-50 max-h-96 overflow-y-auto';
            dropdownContainer.style.minWidth = '250px'; // Wider for better readability with groups
            dropdownContainer.classList.add('hidden'); // Ensure dropdown is hidden on load

            // Define event type groups for better organization
            const eventGroups = [
                {
                    name: 'Planning Events',
                    color: '#e0f2fe',
                    types: ['spCutoff', 'spFeedback', 'tradeOffDiscussion', 'finalSSIMHandover']
                },
                {
                    name: 'Publish Events',
                    color: '#fef9c3',
                    types: ['techCrewPublish', 'cabinCrewPublish']
                },
                {
                    name: 'Training Handover',
                    color: '#e9d5ff',
                    types: ['trainingHandoverTech', 'trainingHandoverCabin']
                },
                {
                    name: 'Roster Build',
                    color: '#bbf7d0',
                    types: ['rosterBuildCommenceTech', 'rosterBuildCommenceCabin']
                },
                {
                    name: 'Bidding Closure',
                    color: '#fed7aa',
                    types: ['biddingClosureTech', 'biddingClosureCabin']
                },
                {
                    name: 'CB Pairing Publish',
                    color: '#99f6e4',
                    types: ['cbPairingPublishTech', 'cbPairingPublishCabin']
                },
                {
                    name: 'Other',
                    color: '#f3f4f6',
                    types: ['publicHoliday']
                }
            ];

            const allEventTypes = {
                ...eventTypes,
                publicHoliday: { label: "Public Holiday", type: "holiday" } // Add Public Holiday as a filterable type
            };

            // Ensure appSettings.eventTypeVisibility is initialized
            if (!appSettings.eventTypeVisibility) {
                appSettings.eventTypeVisibility = {};
                Object.keys(allEventTypes).forEach(key => {
                    appSettings.eventTypeVisibility[key] = true; // Default to true
                });
            }

            // Create a select all checkbox at the top
            const allContainer = document.createElement('div');
            allContainer.className = 'px-2 py-2 border-b border-gray-200';
            
            const allLabel = document.createElement('label');
            allLabel.className = 'flex items-center font-semibold';
            
            const allCheckbox = document.createElement('input');
            allCheckbox.type = 'checkbox';
            allCheckbox.id = 'filter-all';
            
            // Check if all events are currently visible
            const allVisible = Object.keys(allEventTypes).every(key => 
                appSettings.eventTypeVisibility[key] !== false
            );
            allCheckbox.checked = allVisible;
            
            allCheckbox.addEventListener('change', (event) => {
                const isChecked = event.target.checked;
                
                // Update all checkboxes
                document.querySelectorAll('#eventFilterDropdown input[type="checkbox"]').forEach(cb => {
                    if (cb !== allCheckbox) {
                        cb.checked = isChecked;
                        // Update settings for this specific checkbox
                        const eventKey = cb.name;
                        if (eventKey) {
                            appSettings.eventTypeVisibility[eventKey] = isChecked;
                        }
                    }
                });
                
                // Save settings and update calendar
                localStorage.setItem('appSettings', JSON.stringify(appSettings));
                renderCalendarView();
            });
            
            allLabel.appendChild(allCheckbox);
            allLabel.appendChild(document.createTextNode(' Select All'));
            allContainer.appendChild(allLabel);
            dropdownContainer.appendChild(allContainer);

            // Create each group with its events
            eventGroups.forEach(group => {
                // Create group header
                const groupHeader = document.createElement('div');
                groupHeader.className = 'px-2 py-2 font-medium text-gray-700 border-t border-gray-200';
                groupHeader.style.backgroundColor = group.color + '40'; // Add transparency
                groupHeader.textContent = group.name;
                dropdownContainer.appendChild(groupHeader);
                
                // Add checkbox for each event type in this group
                group.types.forEach(typeKey => {
                    if (!allEventTypes[typeKey]) return; // Skip if event type doesn't exist
                    
                    const typeLabel = allEventTypes[typeKey].label;
                    
                    const label = document.createElement('label');
                    label.className = 'flex items-center whitespace-nowrap px-4 py-1 hover:bg-gray-100'; // Indented with padding
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.id = `filter-${typeKey}`;
                    checkbox.name = typeKey;
                    checkbox.checked = appSettings.eventTypeVisibility[typeKey] !== false; // Default to true if undefined
                    
                    checkbox.addEventListener('change', (event) => {
                        appSettings.eventTypeVisibility[typeKey] = event.target.checked;
                        
                        // Update 'Select All' checkbox state
                        const allStillChecked = Object.keys(allEventTypes).every(key => 
                            appSettings.eventTypeVisibility[key] !== false
                        );
                        document.getElementById('filter-all').checked = allStillChecked;
                        
                        localStorage.setItem('appSettings', JSON.stringify(appSettings)); // Save updated settings
                        renderCalendarView(); // Re-render the calendar
                    });
                    
                    label.appendChild(checkbox);
                    label.appendChild(document.createTextNode(` ${typeLabel}`)); // Add space before label text
                    dropdownContainer.appendChild(label);
                });
            });
        }

    </script>
</body>
</html>
</file_content>
<environment_details>
# VSCode Visible Files
planning-dates-calculator 1.html

# VSCode Open Tabs
planning-dates-calculator 1.html

# Current Time
5/15/2025, 4:01:40 PM (Australia/Sydney, UTC+10:00)

# Context Window Usage
829,640 / 1,048.576K tokens used (79%)

# Current Mode
ACT MODE
</environment_details>
